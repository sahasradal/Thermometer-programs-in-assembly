
AVRASM ver. 2.2.7  C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm Fri May 13 18:01:22 2022

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATtiny_DFP\1.3.229\avrasm\inc\tn10def.inc'
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(22): warning: Register r28 already defined by the .DEF directive
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(23): warning: Register r29 already defined by the .DEF directive
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(24): warning: Register r27 already defined by the .DEF directive
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATtiny_DFP\1.3.229\avrasm\inc\tn10def.inc'
                                 
                                 ;
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATtiny10.xml ************
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "tn10def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATtiny10
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATtiny10
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _TN10DEF_INC_
                                 #define _TN10DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATtiny10
                                 #pragma AVRPART ADMIN PART_NAME ATtiny10
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x90
                                 .equ	SIGNATURE_002	= 0x03
                                 
                                 #pragma AVRPART CORE CORE_VERSION AVR8L_0
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	CCP	= 0x3c
                                 .equ	RSTFLR	= 0x3b
                                 .equ	SMCR	= 0x3a
                                 .equ	OSCCAL	= 0x39
                                 .equ	CLKMSR	= 0x37
                                 .equ	CLKPSR	= 0x36
                                 .equ	PRR	= 0x35
                                 .equ	VLMCSR	= 0x34
                                 .equ	NVMCMD	= 0x33
                                 .equ	NVMCSR	= 0x32
                                 .equ	WDTCSR	= 0x31
                                 .equ	GTCCR	= 0x2f
                                 .equ	TCCR0A	= 0x2e
                                 .equ	TCCR0B	= 0x2d
                                 .equ	TCCR0C	= 0x2c
                                 .equ	TIMSK0	= 0x2b
                                 .equ	TIFR0	= 0x2a
                                 .equ	TCNT0L	= 0x28
                                 .equ	TCNT0H	= 0x29
                                 .equ	OCR0AL	= 0x26
                                 .equ	OCR0AH	= 0x27
                                 .equ	OCR0BL	= 0x24
                                 .equ	OCR0BH	= 0x25
                                 .equ	ICR0L	= 0x22
                                 .equ	ICR0H	= 0x23
                                 .equ	ACSR	= 0x1f
                                 .equ	ADCSRA	= 0x1d
                                 .equ	ADCSRB	= 0x1c
                                 .equ	ADMUX	= 0x1b
                                 .equ	ADCL	= 0x19
                                 .equ	DIDR0	= 0x17
                                 .equ	EICRA	= 0x15
                                 .equ	EIFR	= 0x14
                                 .equ	EIMSK	= 0x13
                                 .equ	PCICR	= 0x12
                                 .equ	PCIFR	= 0x11
                                 .equ	PCMSK	= 0x10
                                 .equ	PORTCR	= 0x0c
                                 .equ	PUEB	= 0x03
                                 .equ	PORTB	= 0x02
                                 .equ	DDRB	= 0x01
                                 .equ	PINB	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel Selection Bits
                                 
                                 ; ADCSRA - The ADC Control and Status register A
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCSRB - The ADC Control and Status register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                                 
                                 ; ADCL - ADC Data Register
                                 .equ	ADC0	= 0	; ADC Data Register Bit 0
                                 .equ	ADC1	= 1	; ADC Data Register Bit 1
                                 .equ	ADC2	= 2	; ADC Data Register Bit 2
                                 .equ	ADC3	= 3	; ADC Data Register Bit 3
                                 .equ	ADC4	= 4	; ADC Data Register Bit 4
                                 .equ	ADC5	= 5	; ADC Data Register Bit 5
                                 .equ	ADC6	= 6	; ADC Data Register Bit 6
                                 .equ	ADC7	= 7	; ADC Data Register Bit 7
                                 
                                 ; DIDR0 - Digital Input Disable Register
                                 .equ	ADC0D	= 0	; 
                                 .equ	ADC1D	= 1	; 
                                 .equ	ADC2D	= 2	; 
                                 .equ	ADC3D	= 3	; 
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture  Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR0 - 
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** CPU **************************
                                 ; CCP - Configuration Change Protection
                                 .equ	CCP0	= 0	; Configuration Change Protection bit 0
                                 .equ	CCP1	= 1	; Configuration Change Protection bit 1
                                 .equ	CCP2	= 2	; Configuration Change Protection bit 2
                                 .equ	CCP3	= 3	; Configuration Change Protection bit 3
                                 .equ	CCP4	= 4	; Configuration Change Protection bit 4
                                 .equ	CCP5	= 5	; Configuration Change Protection bit 5
                                 .equ	CCP6	= 6	; Configuration Change Protection bit 6
                                 .equ	CCP7	= 7	; Configuration Change Protection bit 7
                                 
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; CLKMSR - Clock Main Settings Register
                                 .equ	CLKMS0	= 0	; Clock Main Select Bit 0
                                 .equ	CLKMS1	= 1	; Clock Main Select Bit 1
                                 
                                 ; CLKPSR - Clock Prescale Register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select Bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select Bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select Bit 2
                                 
                                 ; PRR - Power Reduction Register
                                 .equ	PRTIM0	= 0	; Power Reduction Timer/Counter0
                                 .equ	PRADC	= 1	; Power Reduction ADC
                                 
                                 ; VLMCSR - Vcc Level Monitoring Control and Status Register
                                 .equ	VLM0	= 0	; Trigger Level of Voltage Level Monitor bit 0
                                 .equ	VLM1	= 1	; Trigger Level of Voltage Level Monitor bit 1
                                 .equ	VLM2	= 2	; Trigger Level of Voltage Level Monitor bit 2
                                 .equ	VLMIE	= 6	; VLM Interrupt Enable
                                 .equ	VLMF	= 7	; VLM Flag
                                 
                                 ; RSTFLR - Reset Flag Register
                                 .equ	PORF	= 0	; Power-on Reset Flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 
                                 ; NVMCSR - Non-Volatile Memory Control and Status Register
                                 .equ	NVMBSY	= 7	; Non-Volatile Memory Busy
                                 
                                 ; NVMCMD - Non-Volatile Memory Command
                                 .equ	NVMCMD0	= 0	; 
                                 .equ	NVMCMD1	= 1	; 
                                 .equ	NVMCMD2	= 2	; 
                                 .equ	NVMCMD3	= 3	; 
                                 .equ	NVMCMD4	= 4	; 
                                 .equ	NVMCMD5	= 5	; 
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTCR - Port Control Register
                                 .equ	BBMB	= 1	; Break-Before-Make Mode Enable
                                 
                                 ; PUEB - Pull-up Enable Control Register
                                 .equ	PUEB0	= 0	; 
                                 .equ	PUEB1	= 1	; 
                                 .equ	PUEB2	= 2	; 
                                 .equ	PUEB3	= 3	; 
                                 
                                 ; PORTB - Input Pins, Port B
                                 .equ	PORTB0	= 0	; 
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; 
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; 
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; 
                                 .equ	PB3	= 3	; For compatibility
                                 
                                 ; DDRB - Data Direction Register, Port B
                                 .equ	DDB0	= 0	; 
                                 .equ	DDB1	= 1	; 
                                 .equ	DDB2	= 2	; 
                                 .equ	DDB3	= 3	; 
                                 
                                 ; PINB - Port B Data register
                                 .equ	PINB0	= 0	; 
                                 .equ	PINB1	= 1	; 
                                 .equ	PINB2	= 2	; 
                                 .equ	PINB3	= 3	; 
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 
                                 ; EIMSK - External Interrupt Mask register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 
                                 ; EIFR - External Interrupt Flag register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 
                                 ; PCMSK - Pin Change Mask Register
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0A - Timer/Counter 0 Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode for Channel B bit 0
                                 .equ	COM0B1	= 5	; Compare Output Mode for Channel B bit 1
                                 .equ	COM0A0	= 6	; Compare Output Mode for Channel A bit 0
                                 .equ	COM0A1	= 7	; Compare Output Mode for Channel A bit 1
                                 
                                 ; TCCR0B - Timer/Counter 0 Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; Waveform Generation Mode
                                 .equ	WGM03	= 4	; Waveform Generation Mode
                                 .equ	ICES0	= 6	; Input Capture Edge Select
                                 .equ	ICNC0	= 7	; Input Capture Noise Canceler
                                 
                                 ; TCCR0C - Timer/Counter 0 Control Register C
                                 .equ	FOC0B	= 6	; Force Output Compare for Channel B
                                 .equ	FOC0A	= 7	; Force Output Compare for Channel A
                                 
                                 ; TIMSK0 - Timer Interrupt Mask Register 0
                                 .equ	TOIE0	= 0	; Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Output Compare A Match Interrupt Enable
                                 .equ	OCIE0B	= 2	; Output Compare B Match Interrupt Enable
                                 .equ	ICIE0	= 5	; Input Capture Interrupt Enable
                                 
                                 ; TIFR0 - Overflow Interrupt Enable
                                 .equ	TOV0	= 0	; Timer Overflow Flag
                                 .equ	OCF0A	= 1	; Timer Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer Output Compare Flag 0B
                                 .equ	ICF0	= 5	; Input Capture Flag
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSR	= 0	; Prescaler Reset
                                 .equ	TSM	= 7	; Timer Synchronization Mode
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control and Status Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timer Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timer Interrupt Flag
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lockbit
                                 .equ	LB2	= 1	; Lockbit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; BYTE0 fuse bits
                                 .equ	RSTDISBL	= 0	; Disable external reset
                                 .equ	WDTON	= 1	; Watch dog timer always on
                                 .equ	CKOUT	= 2	; Output external clock
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x01ff	; Note: Word address
                                 .equ	IOEND	= 0x003f
                                 .equ	SRAM_START	= 0x0040
                                 .equ	SRAM_SIZE	= 32
                                 .equ	RAMEND	= 0x005f
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x0000
                                 .equ	EEPROMEND	= 0x0000
                                 
                                 ; ***** MEMORY MAPPED NVM ************************************************
                                 .equ	MAPPED_FLASH_START	= 0x4000
                                 .equ	MAPPED_LOCKBITS_0	= 0x3f00
                                 .equ	MAPPED_CONFIG_0	= 0x3f40
                                 .equ	MAPPED_CALIB_0	= 0x3f80
                                 .equ	MAPPED_SIGN_0	= 0x3fc0
                                 .equ	MAPPED_SIGN_1	= 0x3fc1
                                 .equ	MAPPED_SIGN_2	= 0x3fc2
                                 .equ	MAPPED_FLASH_SIZE	= 0x0400
                                 .equ	MAPPED_FLASH_END	= 0x43ff
                                 #pragma AVRPART MEMORY PROG_FLASH 1024
                                 #pragma AVRPART MEMORY EEPROM 0
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 32
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x40
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	PAGESIZE	= 16
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                                 .equ	PCI0addr	= 0x0002	; Pin Change Interrupt Request 0
                                 .equ	ICP0addr	= 0x0003	; Timer/Counter0 Input Capture
                                 .equ	OVF0addr	= 0x0004	; Timer/Counter0 Overflow
                                 .equ	OC0Aaddr	= 0x0005	; Timer/Counter Compare Match A
                                 .equ	OC0Baddr	= 0x0006	; Timer/Counter Compare Match B
                                 .equ	ACIaddr	= 0x0007	; Analog Comparator
                                 .equ	WDTaddr	= 0x0008	; Watchdog Time-out
                                 .equ	VLMaddr	= 0x0009	; Vcc Voltage Level Monitor
                                 .equ	ADCCaddr	= 0x000a	; ADC Conversion Complete
                                 
                                 .equ	INT_VECTORS_SIZE	= 11	; size in words
                                 
                                 #pragma AVRPART CORE INSTRUCTIONS_NOT_SUPPORTED break
                                 
                                 #endif  /* _TN10DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; Attiny10thermometerTM1637display.asm
                                 ;
                                 ; Created: 04/05/2022 09:06:49
                                 ; Author : Manama
                                 ;
                                 
                                 
                                 ;pb0 is SDA
                                 ;pb2 is SCL
                                 ;pb1 is data line for temp sensor
                                 
                                 .def temp = r16
                                 .def data = r17
                                 .def counter = r18
                                 .def array_length = r19
                                 .def array_byte = r20
                                 .def ASCII = r21
                                 .def temp1 = r22
                                 .def posx = r23
                                 .def posy = r24
                                 .def result_low = r28
                                 .def result_high = r29
                                 .def result = r27
                                 
                                 .equ fclk = 1000000
                                 .equ displayon  = 0b10001001		; command 0x80 + display on = 8 + brightness 1 =0x89
                                 .equ displayoff = 0b10000001
                                 .equ address1 = 0xC2
                                 .equ address2 = 0xC1
                                 .equ address3 = 0xC0
                                 .equ address4 = 0xC5
                                 .equ address5 = 0xC4
                                 .equ address6 = 0xC3
                                 
                                 .equ search_rom = 0xf0
                                 .equ read_rom = 0x33
                                 .equ match_rom = 0x55
                                 .equ skip_rom = 0xcc
                                 .equ alarm_search = 0xec
                                 .equ convert = 0x44
                                 .equ write_scratchpad = 0x4e
                                 .equ read_sscratchpad = 0xbe
                                 .equ copy_scratchpad = 0x48
                                 .equ recall_E2 = 0xb8
                                 .equ read_powersupply = 0xb4
                                 
                                 .macro printf						;macro to print characters on OLED
                                 ldi temp,@0							
                                 mov ASCII,temp
                                 rcall print
                                 .endm 
                                 
                                 
                                 .macro DALLAS_COMMAND				; macro to send rom commands to sensor
                                 ldi temp1,@0
                                 rcall ROM_COMMANDS
                                 .endm
                                 
                                 .macro F_COMMANDS					; macro to send function commands to sensor
                                 ldi temp1,@0
                                 rcall f_command
                                 .endm
                                 
                                 .macro micros						; macro for micro seconds delay
                                 ldi r26,((@0-10)/3)
                                 rcall delayus
                                 .endm
                                 
                                 .macro command2
                                 ldi data,@0
                                 rcall spitx
                                 .endm
                                 
                                 
                                 .dseg
000040                           PAD:		.byte 1				; temp space for calculation
000041                           presence:	.byte 1				; stores response of ds18b20 during init
000042                           minussign:	.byte 1				; stores minus sign if result is negative else store space for positive result
000043                           firstdigit: .byte 1				; 100th position of result whole number
000044                           seconddigit:.byte 1				; 10th position of result whole number
000045                           thirddigit: .byte 1				; unit position of result whole number
000046                           firstplace: .byte 1				; stores ascii value of 1st fraction
000047                           secplace:	.byte 1				; stores ascii value of 2nd fraction
000048                           thirdplace: .byte 1				; stores ascii value of 3rd fraction
000049                           fourthplace:.byte 1				; stores ascii value of 4th fraction
00004a                           SCRATCHPAD: .byte 2				; stores temprature high byte & low byte value copied from ds18b20sensor
                                 
                                 
                                 .cseg
                                 reset:
000000 e005                      	ldi temp,0b00000101			; value to initialise portb and direction register for dataa and clock , pb0 , pb1
000001 b901                      	out ddrb,temp				; initialize PB0 and PB2 as outputs (for TM1637 display)
000002 b902                      	out portb,temp				; set both PB0 and PB2 ports high
                                 
                                 main_loop:
000003 d0c8                      	rcall measure				;call subroutine to measure temprature (read sensor,convert to decimal,convert to ASCII,store in SRAM)
000004 e403                      	ldi r16, 'C'				;the last 3 fraction values are not printed,instead we use the space to print letter C, -100.1C
000005 a907                      	sts secplace,r16			;the last 3 fraction values are not printed,instead we use the space to print letter C, -100.1C
                                 printtemp:
000006 e4c2                      	ldi YL,low(minussign)		; set Y pointer to location minussign in SRAM , all data to be displayed stored in SRAM consicutive locations
000007 e0d0                      	ldi YH,high(minussign)
000008 e096                      	ldi r25,6					; total 6 characters are displayed , so counter value 6
000009 d020                      	rcall command1				; transmits command1 which tells TM1637 that fixed address mode is being used to send data that follows
00000a ec12
00000b d055                      	command2 address1			; transmit the 1st address of the display (here its the left most digit of the unit )
00000c 9159                      	ld ASCII,Y+					; ASCII (r21) used for address calculation of fonts
00000d d056                      	rcall printchar				; call printchar function to calculate address of the font and transmit data to TM1637 display
00000e 959a                      	dec r25						; decrease counter , value used to print decimal at required location inside printchar routine
00000f ec11
000010 d050                      	command2 address2			; transmit the 2st address of the display
000011 9159                      	ld ASCII,Y+
000012 d051                      	rcall printchar
000013 959a                      	dec r25
000014 ec10
000015 d04b                      	command2 address3			; transmit the 3rd address of the display
000016 9159                      	ld ASCII,Y+
000017 d04c                      	rcall printchar
000018 959a                      	dec r25
000019 ec15
00001a d046                      	command2 address4			; transmit the 4th address of the display
00001b 9159                      	ld ASCII,Y+
00001c d047                      	rcall printchar
00001d 959a                      	dec r25
00001e ec14
00001f d041                      	command2 address5			; transmit the 5th address of the display
000020 9159                      	ld ASCII,Y+
000021 d042                      	rcall printchar
000022 959a                      	dec r25
000023 ec13
000024 d03c                      	command2 address6			; transmit the 6th address of the display, last address as this is 6digit display , rightmost digit
000025 9159                      	ld ASCII,Y+
000026 d03d                      	rcall printchar
000027 959a                      	dec r25
000028 d005                      	rcall command3				; transmit the display command which turns on the display
000029 cfd9                      	rjmp main_loop				; loop again infinitely till power available
                                 
                                 
                                 
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;TM1637 ROUTINES     register used-                                                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 command1:
00002a e414                      	ldi data,0x44		;0x40 commannd for automatic address increment,0x44 for fixed address mode (address has to be supplied for each digit)
00002b d035                      	rcall spitx
00002c d00d                      	rcall stop			;a stop has to be issued as per data sheet for data command setting (0x40 or 0x44 above)
00002d 9508                      	ret
                                 command3:
00002e e819                      	ldi data,displayon	;(load display command) 0x80 OR 0x01(brightness value bit0 to bit2,we use 1) OR 0x08(display on) = 0x89
00002f d031                      	rcall spitx
000030 d009                      	rcall stop
000031 9508                      	ret
                                 
                                 start:
000032 9a10                      	sbi portb,0			;set data pb0
000033 9a12                      	sbi portb,2			;set clk  pb2
000034 d0ed                      	rcall us10
000035 9810                      	cbi portb,0
000036 d0eb                      	rcall us10
000037 9812                      	cbi portb,2
000038 d0e9                      	rcall us10
000039 9508                      	ret
                                 stop:
00003a 9810                      	cbi portb,0
00003b 9812                      	cbi portb,2
00003c d0e5                      	rcall us10
00003d 9a12                      	sbi portb,2
00003e d0e3                      	rcall us10
00003f 9a10                      	sbi portb,0
000040 d0e1                      	rcall us10
000041 9508                      	ret
                                 SPI:
000042 e028                      	ldi r18,8
                                 tx:
000043 9516                      	lsr data			; shift right data to move lsb to carry , TM1637 needs lsb 1st
000044 f070                      	brcs hi				; if crry set bit shifted is 1 branch to label hi to transmit 1
000045 9810                      	cbi portb,0			; reach here if carry not set while right shift, pull data low to transmit 0
000046 d0db                      	rcall us10			; delay 10us for settling data line (tm1637 is little slow as per data sheet)
000047 9a12                      	sbi portb,2			; make clock hi 
000048 d0d9                      	rcall us10			; delay 10us
000049 9812                      	cbi portb,2			; make clock line low ,data aquisition finished , 0 bit clocked in to TM1637
00004a d0d7                      	rcall us10			; delay 10us
00004b 952a                      	dec r18				; decrease counter 
00004c f7b1                      	brne tx				; check all 8 bits are transmitted else loop to label TX
00004d 9a10                      	sbi portb,0			; if all 8 bits are transmitted , make data high ,  data line will be pulled down by TM1637 to transmit ACK
00004e 9a12                      	sbi portb,2			; make clock high , clock in ACK (9th clock) so that TM1637 releases the data line from low
00004f d0d2                      	rcall us10			; delay 10 us
000050 9810                      	cbi portb,0			; pull data low , default state after start is issued
000051 9812                      	cbi portb,2			; make clock low , 9th clock completed
000052 9508                      	ret					; return to caller
                                 hi:
000053 9a10                      	sbi portb,0			; reach here if carry  while right shift, pull data up to transmit 1
000054 d0cd                      	rcall us10			; delay 10us
000055 9a12                      	sbi portb,2			; make clock hi
000056 d0cb                      	rcall us10			; delay 10us
000057 9812                      	cbi portb,2			; make clock low
000058 d0c9                      	rcall us10			; delay 10us
000059 952a                      	dec r18				; decrease counter
00005a f741                      	brne tx				; check all 8 bits are transmitted else loop to label TX
00005b 9a10                      	sbi portb,0			; if all 8 bits are transmitted , make data high ,  data line will be pulled down by TM1637 to transmit ACK
00005c 9a12                      	sbi portb,2			; make clock high , clock in ACK (9th clock) so that TM1637 releases the data line from low
00005d d0c4                      	rcall us10			; delay 10 us
00005e 9810                      	cbi portb,0			; pull data low , default state after start is issued		
00005f 9812                      	cbi portb,2			; make clock low , 9th clock completed
000060 9508                      	ret					; return to caller
                                 	
                                 spitx:
000061 dfd0                      	rcall start
000062 dfdf                      	rcall SPI
000063 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;PRINTCHAR function   
                                 ;characters to be printed has to be passed into register ASCII as ASCII values, only 0,1,2,3,4,5,6,7,8,9,-,., ,C are supported
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 printchar:	
000064 325d                      	cpi ASCII,'-'						; minus
000065 f029                      	breq minus1							; branch to label minus1
000066 3453                      	cpi ASCII,'C'						; ascii C
000067 f031                      	breq letterC						; branch to label letterC
000068 3250                      	cpi ASCII,' '						; space
000069 f039                      	breq space							; branch to lbel space
00006a c009                      	rjmp print							; if none of above jump to label print which loads the first font '0'and calculates the relative position
                                 
                                 minus1:
00006b e3e2                      	ldi ZL,low((2*fontminus)+0x4000)	;attiny10 doesnt allow direct flash read,should access via SRAM address starting at 0x4000 as per data sheet
00006c e4f1                      	ldi ZH,high((2*fontminus)+0x4000)	;pointer set to font array for - minus
00006d c011                      	rjmp ASCII0
                                 
                                 letterC:
00006e e2ea                      	ldi ZL,low((2*fontC)+0x4000)		;attiny10 doesnt allow direct flash read,should access via SRAM address starting at 0x4000 as per data sheet
00006f e4f1                      	ldi ZH,high((2*fontC)+0x4000)		;pointer set to font array for letter C
000070 c00e                      	rjmp ASCII0
                                 
                                 space:
000071 e3e4                      	ldi ZL,low((2*fontspace)+0x4000)	;attiny10 doesnt allow direct flash read,should access via SRAM address starting at 0x4000 as per data sheet
000072 e4f1                      	ldi ZH,high((2*fontspace)+0x4000)	;pointer set to font array for space
000073 c00b                      	rjmp ASCII0
                                 
                                 
                                 print:
000074 e1e2                      	ldi ZL,low((2*font0)+0x4000)	;attiny10 doesnt allow direct flash read,should access via SRAM address starting at 0x4000 as per data sheet
000075 e4f1                      	ldi ZH,high((2*font0)+0x4000)
000076 e340                      	ldi array_byte,0x30   		;hex value of first ASCII caharacter in font aray is 0x30 .subtract start value from ASCII value returned from ASCII_CONVERTER to know the position of character in the array
000077 1b54                      	sub ASCII,array_byte		;result of subtraction will be position of first byte of the character
000078 f031                      	breq ASCII0					;if the result is 0 go to label ASCII0 and print 6 bytes which is a space (0x20 = space in the font array,1st character)
000079 2700                      	clr temp					;clear temp for counting
                                 multiply:
00007a 5fee                      	subi r30,low(-2)			;adding immediate not suppported. immediate extends beyond 8bit.using subi & sbci with -ve number will do & loading with hi &lo will propogate carry.
00007b 4fff                      	sbci r31,high(-2)
00007c 9503                      	inc temp					;counter increased on each iteration
00007d 1705                      	cp temp,ASCII				;counter is compared to value in ASCII register(start address of the array row)
00007e f7d9                      	brne multiply				;if the atart address not reached loop back through the code from label "multiply"
                                 ASCII0:
00007f 8110                      	ld data,Z					; call routine font_write which prints font on LCD
000080 3093                      	cpi r25,3					; this number decides where the decimal point will be placed , 3 means decimal will be placed on 4th digit from left most digit
000081 f019                      	breq adddecimal				; if equal to 3 branch to adddecimal label to OR with 0x80 which will turn on the decimal point
000082 dfde                      	rcall spitx					; transmit data to TM1637 screen
000083 dfb6                      	rcall stop					; transmit stop to screen
000084 9508                      	ret
                                 adddecimal:
000085 6810                      	ori data,0x80				; OR 0x80 to the value in data to light up the decimal point, 0x80 is the decimal point segment data
000086 dfda                      	rcall spitx					; transmit data to TM1637 screen
000087 dfb2                      	rcall stop					;transmit stop to screen
000088 9508                      	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;FONTS   fonts below 16bytes ,hence array lenth =16
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 // XGFEDCBA
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(270): warning: .cseg .db misalignment - padding zero byte
000089 003f                      font0: .db   0b00111111    // 0
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(271): warning: .cseg .db misalignment - padding zero byte
00008a 0006                      font1: .db   0b00000110    // 1
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(272): warning: .cseg .db misalignment - padding zero byte
00008b 005b                      font2: .db   0b01011011    // 2
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(273): warning: .cseg .db misalignment - padding zero byte
00008c 004f                      font3: .db   0b01001111    // 3
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(274): warning: .cseg .db misalignment - padding zero byte
00008d 0066                      font4: .db   0b01100110    // 4
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(275): warning: .cseg .db misalignment - padding zero byte
00008e 006d                      font5: .db   0b01101101    // 5
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(276): warning: .cseg .db misalignment - padding zero byte
00008f 007d                      font6: .db   0b01111101    // 6
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(277): warning: .cseg .db misalignment - padding zero byte
000090 0007                      font7: .db   0b00000111    // 7
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(278): warning: .cseg .db misalignment - padding zero byte
000091 007f                      font8: .db   0b01111111    // 8
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(279): warning: .cseg .db misalignment - padding zero byte
000092 006f                      font9: .db   0b01101111    // 9
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(280): warning: .cseg .db misalignment - padding zero byte
000093 0077                      fonta: .db   0b01110111    // A
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(281): warning: .cseg .db misalignment - padding zero byte
000094 007c                      fontb: .db   0b01111100    // b
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(282): warning: .cseg .db misalignment - padding zero byte
000095 0039                      fontc: .db   0b00111001    // C
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(283): warning: .cseg .db misalignment - padding zero byte
000096 005e                      fontd: .db   0b01011110    // d
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(284): warning: .cseg .db misalignment - padding zero byte
000097 0079                      fonte: .db   0b01111001    // E
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(285): warning: .cseg .db misalignment - padding zero byte
000098 0071                      fontf: .db   0b01110001    // F
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(286): warning: .cseg .db misalignment - padding zero byte
000099 0040                      fontminus: .db  0b01000000    // -
C:\Users\Manama\Documents\Atmel Studio\7.0\Attiny10thermometerTM1637display\Attiny10thermometerTM1637display\main.asm(287): warning: .cseg .db misalignment - padding zero byte
00009a 0000                      fontspace: .db  0b00000000
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 
                                 calc_fraction:
00009b 27ff                      	clr r31					; clear r31 used for carry propagation in multibyte addition
00009c e741                      	ldi r20,low(625)		; load r20 with 625 (scaled value of 0.0625 degC), we multiply with 625 and place decimal point in the LCD between fraction and main
00009d e052                      	ldi r21,high(625)		; load r20 with 625 (scaled value of 0.0625 degC)
00009e 2f64                      	mov r22,r20				; copy the 625 so that it can be added to itself , total added value in R23:r22
00009f 2f75                      	mov r23,r21				; copy the 625 so that it can be added to itself , total added value in R23:r22
0000a0 3031                      	cpi r19,1				; check if fraction value of the result copied to r19 in binary_decimal subroutine is equal to 1
0000a1 f041                      	breq getout				; if 1 branch to label getout as no multiplication is needed and least value of 0.0625 is already in regiser
0000a2 3030                      	cpi r19,0				; check if value of fraction in r19 is 0 , if 0 no multiplication needed just clear registers and exit
0000a3 f049                      	breq clrnexit			; if 0 branch to label clrnexit 
0000a4 953a                      	dec r19
                                 fmultiply:
0000a5 0f64                      	add r22,r20				; add 625 to 625
0000a6 1f75                      	adc r23,r21				; add with carry
0000a7 1f8f                      	adc r24,r31				; add with carry
0000a8 953a                      	dec r19					; decrease r19 after each addition
0000a9 f7d9                      	brne fmultiply			; if r19 not reached 0 loop back to fmultiply label till all additions have finished
                                 getout:
0000aa 2744                      	clr r20					; clear registers 625 is in r22, we reach here if r19 was 1 = 0.0625 * 1
0000ab 2755                      	clr r21					; clear registers 625 is in r22, we reach here if r19 was 1 = 0.0625 * 1
0000ac 9508                      	ret						; result in r24:r23:R22
                                 clrnexit:
0000ad 2777                      	clr r23					; clear register as there is no fraction , we reach here if r19 was 0 = no fraction, result whole number
0000ae 2766                      	clr r22					; clear register as there is no fraction , we reach here if r19 was 0 = no fraction, result whole number
0000af 9508                      	ret						; result in r24:r23:R22
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;f_command used for sending function command to sensor, use F_COMMANDS macro
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 f_command:
0000b0 e098                      	ldi r25,8					; counter value of 8 for 8 bits
0000b1 2f86                      	mov r24,r22					; macro F_COMMANDS loads value of the command to r22 which is now copied to r24
                                 loop51:
0000b2 9586                      	lsr r24						; shift right r24 to carry in SREG
0000b3 f020                      	brcs high2					; branch to hihg2 label if carray flag set,  means shifted bit is 1 
0000b4 d045                      	rcall write0				; call routine write0 to send 0 to sensor, reach here because carry flag didnt set during right shift means bit 0
0000b5 959a                      	dec r25						; decrease counter		
0000b6 f7d9                      	brne loop51					; do same for each bit until counter is 0, all bits transmitted
0000b7 9508                      	ret							; return to caller
                                 high2:
0000b8 d039                      	rcall write1				; reach here if right shift set carry flag (bit is 1)
0000b9 959a                      	dec r25						; decrease counter
0000ba f7b9                      	brne loop51					; loop back till all bits are shifted out
0000bb 9508                      	ret							; return to caller
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;ROM_COMMANDS sends rom commands to sensor, use macro DALLAS_COMMAND
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ROM_COMMANDS:
0000bc e098                      	ldi r25,8					; counter value of 8 for 8 bits
0000bd d027                      	rcall dallas_init			; call sensor init to reset sensor
0000be a101                      	lds r16,presence			; copy sensor presense response value from SRAM stored during init routine
0000bf 3000                      	cpi r16,0					; check whether it is 0 (sensor present)
0000c0 f451                      	brne exit0					; any value not 0 indicates sensor missing so exit
0000c1 2f86                      	mov r24,r22					; macro DALLAS_COMMANDS loads value of the command to r22 which is now copied to r24
                                 loop41:
0000c2 9586                      	lsr r24						; shift right r24 to carry in SREG
0000c3 f020                      	brcs high1					; branch to hihg2 label if carray flag set,  means shifted bit is 1
0000c4 d035                      	rcall write0				; call routine write0 to send 0 to sensor, reach here because carry flag didnt set during right shift means bit 0
0000c5 959a                      	dec r25						; decrease counter
0000c6 f7d9                      	brne loop41					; do same for each bit until counter is 0, all bits transmitted
0000c7 9508                      	ret							; return to caller
                                 high1:
0000c8 d029                      	rcall write1				; reach here if right shift set carry flag (bit is 1)
0000c9 959a                      	dec r25						; decrease counter
0000ca f7b9                      	brne loop41					; do same for each bit until counter is 0, all bits transmitted
0000cb 9508                      exit0:	ret						;return to caller
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 measure:
0000cc d018                      	rcall dallas_init				; call sensor init
0000cd ec6c
0000ce dfed                      	DALLAS_COMMAND skip_rom			; send rom command skip_rom with DALLAS_COMMAND macro
0000cf e464
0000d0 dfdf                      	F_COMMANDS convert				; send function command convert with macro F_COMMANDS
                                 
                                 	
                                 check1:
0000d1 d04b                      	rcall bit_read					; call routine bit_read to check busy status of sensor 1 = busy , 0= result ready
0000d2 ff87                      	sbrs r24,7						; skip next command if read value is 1
0000d3 cffd                      	rjmp check1						; loop to check1 if read value is 0 = busy
0000d4 d010                      	rcall dallas_init				; call sensor init to reset sensor
0000d5 0000                      	nop								; delay
0000d6 0000                      	nop								; delay
0000d7 ec6c
0000d8 dfe3                      	DALLAS_COMMAND skip_rom			; send rom command skip_rom with DALLAS_COMMAND macro
0000d9 eb6e
0000da dfd5                      	F_COMMANDS read_sscratchpad		; send function command read_scratchpad with macro F_COMMANDS
0000db d024                      	rcall byte_read					; call byte_read routine to read sensor scratch pad data (total 8 bytes but we are interested in 1st 2 temprature values)
0000dc a98b                      	sts SCRATCHPAD + 1, r24			; store shifted in lsb to sram 
0000dd d022                      	rcall byte_read					; call byte_read routine to read sensor scratch pad data (total 8 bytes but we are interested in 1st 2 temprature values)
0000de a98a                      	sts SCRATCHPAD , r24			; store shifted in lsb to sram
0000df d005                      	rcall dallas_init				; call sensor init to reset sensor and stop transmission
0000e0 d042                      	rcall binary_decimal			; call binary_decimal routine to convert the result in binary to decimal structure
0000e1 9508                      	ret								; return to caller
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 delayus:
0000e2 95aa                      	dec r26							; call & ret = 9cs, dec =1 ,brne =2 
0000e3 f7f1                      	brne delayus
0000e4 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; DS18b0 init/reset routine
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 dallas_init:
0000e5 9a09                      	sbi ddrb,ddb1					;porta 2 is output by setting direction register
0000e6 e9ac
0000e7 dffa                      	micros 480						;minimum time pull down time required for reset
0000e8 9809                      	cbi ddrb,ddb1					;change PA2 to input to verify whether DS1B20 pulls the line low to indicate presence
0000e9 e1a4
0000ea dff7                      	micros 70						;sensor should respond after 60 seconds ,so wait for the minimum time
0000eb b100                      	in r16,PINB						;copy the PA2 PIN value from PORTA_PIN register
0000ec 7002                      	andi r16,0b00000010				;AND with 0x04 the value of r16 ,if 0 sensor responded , if 1 no response at the time of checking
0000ed a901                      	sts presence,r16				;copy value to memory
0000ee e8a5
0000ef dff2                      	micros 410						; wait for the remaining time slot of 460 us
0000f0 0000                      	nop
0000f1 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;write1 - routine to write 1 to DS18B20
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 write1:
0000f2 9a09                      	sbi ddrb,ddb1					;porta 2 is output by setting direction register
0000f3 0000                      	nop								;delay of 3us data line stays low for more than minimum required time
0000f4 0000                      	nop
0000f5 0000                      	nop
0000f6 9809                      	cbi ddrb,ddb1					;data line released by clearing direction register bit. line is pulled up by pullup voltage
0000f7 e1a0
0000f8 dfe9                      	micros 60						;The delay of 60us to finish the time slot as per data sheet
0000f9 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;write0 - routine to write 0 to DS18B20
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 write0:
0000fa 9a09                      	sbi ddrb,ddb1					;porta 2 is output by setting direction register
0000fb e1a0
0000fc dfe5                      	micros 60						;delay 60us
0000fd 9809                      	cbi ddrb,ddb1					;data line released by clearing direction register bit. line is pulled up by pullup voltage
0000fe d023                      	rcall us10
0000ff 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;byte-read - routine to read a byte from DS18B20
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 byte_read:
000100 e098                      	ldi r25,8						; counter value 8 for 8 bits of a byte
000101 2788                      	clr r24							; byte is assembled here bit by bit
                                 loopread:
000102 9a09                      	sbi ddrb,ddb1					;porta 2 is output by setting direction register
000103 0000                      	nop								;delay of minimum 1 us as per data sheet
000104 0000                      	nop
000105 0000                      	nop
000106 9809                      	cbi ddrb,ddb1					;clear direction register to release data line and turn the master to input
000107 0000                      	nop
000108 0000                      	nop
000109 0000                      	nop
00010a 0000                      	nop
00010b 0000                      	nop
00010c 0000                      	nop
00010d 9901                      	sbic pinb,pinb1					;skip next instruction (one = reading a 1) if pinb register 1 value is 0
00010e c007                      	rjmp one						;if 1 branch to label one
00010f 9488                      	clc								;clear carry bit in SREG
000110 9587                      	ror r24							;rotate right through carry (0 is shifted into msb of r20 from carry,ds18B20 transmits lsb of LSBYTE firt.At the end the first bit in MSB reaches LSB
000111 e0ad
000112 dfcf                      	micros 50						;wait for the remaining time slot of the read bit
000113 959a                      	dec r25							;decrease counter
000114 f769                      	brne loopread					;if counter not 0 branch back to loop3
000115 9508                      	ret								;return to caller
                                 one:
000116 9408                      	sec								;set carry bit in SREG
000117 9587                      	ror r24							;rotate through carry and the carry bit1 will be shifted to MSB of r20 , bit7 >>>>>>> bit0
000118 e0ad
000119 dfc8                      	micros 50						;wait for the remaining time slot of the read bit
00011a 959a                      	dec r25							;decrease counter	
00011b f731                      	brne loopread					;if counter not 0 branch back to loop3
00011c 9508                      	ret								;return to caller
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;bit_read - reads a bit from 18B20 , mainly used to check sensor is busy or not 1= ready , 0 = busy
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 bit_read:
00011d e091                      	ldi r25,1						;load counter value 1, we read 1 bit so value 1
00011e 2788                      	clr r24							;clear r24 where the bit is shifted in
00011f dfe2                      	rcall loopread					;call routine loopread which is part of byte_read to shift in the transmitted bit from the sensor
000120 7880                      	andi r24,0x80					;and r24 with 0x80 , 0 is bit value = 0 , 80h is bit value = 1
000121 9508                      	ret								;return to caller
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;us10 - routine to provide 10us delay
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 us10:
000122 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;binary_decimal   converts binary to decimal
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 binary_decimal:
000123 a11b                      	lds r17,SCRATCHPAD + 1			; copy temprature lsb value from SRAM
000124 a12a                      	lds r18,SCRATCHPAD				; copy temprature msb value from sram
000125 fd27                      	sbrc r18,7						; check whether msb of high byte is cleared means positive number else negative number, if positive skip next instruction
000126 c006                      	rjmp negativeresult				; jump to label negativeresult for negative number clculation		
000127 e200                      	ldi r16,0x20					; load ascii space
000128 a902                      	sts minussign,r16				; store in sram register minussign to clear the leading minus sign as result is positive
000129 2f31                      	mov r19,r17						; copy low byte of temprature to r19 to process fraction , lower nibble is fraction as per ds18b20 data sheet
00012a 703f                      	andi r19,0x0f					; isolate the lower nibble by anding with 80h
00012b df6f                      	rcall calc_fraction				; call calc_fraction subroutine, result is stored in SRAM from firstplace to fourth place in the called routine
00012c c00d                      	rjmp maindigits					; jump to routine maindigits to process the whole number part
                                 negativeresult:
00012d 2733                      	clr r19							; clear r19
00012e a11b                      	lds r17,SCRATCHPAD + 1			; copy temprature lsb value from SRAM
00012f a12a                      	lds r18,SCRATCHPAD				; copy temprature msb value from sram
000130 9520                      	com r18							; take complement
000131 9510                      	com r17							; take complement (converting 2omplement )
000132 5f1f                      	subi r17,-1						; add 1 to get the original positive number represented by 2's complement
000133 2f31                      	mov r19,r17						; copy lsbyte of temprature to r19 to process fraction
000134 a91b                      	sts  SCRATCHPAD + 1,r17			; converted value fron 2's complement is stored back into SRAM for future use in maindigit processing
000135 a92a                      	sts SCRATCHPAD ,r18				; converted value fron 2's complement is stored back into SRAM for future use in maindigit processing
000136 703f                      	andi r19,0x0f					; isolate the lower nibble by anding with 80h
000137 e20d                      	ldi r16,'-'						; load ascii minus sign in r16
000138 a902                      	sts minussign,r16				; store minus sign in SRAM, this will print leading minus in the final OLED display
000139 df61                      	rcall calc_fraction				; call calc_fraction subroutine, result is stored in SRAM from firstplace to fourth place in the called routine
                                 maindigits:
00013a 2f96                      	mov r25,r22						; copy fmultiply results to r26:r25 for ASCII conversion
00013b 2fa7                      	mov r26,r23						; copy fmultiply results to r26:r25 for ASCII conversion
00013c e4e6                      	ldi ZL,low(firstplace)			; set Z pointer to SRAM firstplace where first portion of the fraction number will be stored
00013d e0f0                      	ldi ZH,high(firstplace)
00013e e044                      	ldi r20,4						; length of string 4 as we dont want space loaded at 4th position if leading zero in decimal fraction
00013f d011                      	rcall ASCII_CONVERT				; call ASCII_CONVERT routine that will convert the fraction to ascii values
000140 a11b                      	lds r17,SCRATCHPAD + 1			; copy temprature lsb value from SRAM
000141 a12a                      	lds r18,SCRATCHPAD				; copy temprature msb value from sram
000142 9526                      	lsr r18
000143 9517                      	ror r17
000144 9526                      	lsr r18
000145 9517                      	ror r17
000146 9526                      	lsr r18
000147 9517                      	ror r17
000148 9526                      	lsr r18
000149 9517                      	ror r17							; shift 4 places right r18 & r17 (temp result high & low) to discard the frction value 
00014a 2f91                      	mov r25,r17						; lsbyte of temprature is copied to r25 (ascii_convert input register)
00014b 2fa2                      	mov r26,r18					    ; msbyte of temprature is copied to r26	(ascii_convert input register)	
00014c e4e3                      	ldi ZL,low(firstdigit)			; Z pointer set to SRAM firstdigit where the ascii value of 100th position will be stored by ascii_convert routine
00014d e0f0                      	ldi ZH,high(firstdigit)
00014e e043                      	ldi r20,3						; counter value for Z pointer , 100th, 10th and unit value
00014f d001                      	rcall ASCII_CONVERT				; call ASCII_CONVERT routine that will convert the whole numbers to ascii values 
000150 9508                      	ret								; return to caller
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;* Integer to ASCII converter subrountine here ,
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 ascii_convert:                         ;16 bit entry
                                 				
000151 2733                                      clr     r19            ;digit counter 
000152 9533                                      inc     r19            ;---- decimal string generating 
000153 27bb                                      clr     r27            ;var1 /= 10; temp0
000154 e1c0                                      ldi     r28,16         ; temp1
000155 0f99                                      lsl     r25            ;var0 (binary low)
000156 1faa                                      rol     r26            ;var1 (binary high)
000157 1fbb                                      rol     r27            ;temp0
000158 30ba                                      cpi     r27,10         ;temp0
000159 f010                                      brcs    PC+3           ;
00015a 50ba                                      subi    r27,10         ;temp0
00015b 9593                                      inc     r25            ;var0
00015c 95ca                                      dec     r28            ;temp1
00015d f7b9                                      brne    PC-8           ;/
00015e 5db0                                      subi    r27,-'0'       ;Push the remainder (a decimal digit when added with 0x30 ASCII)
00015f 93bf                                      push    r27            ;/temp0
000160 179c                                      cp      r25,r28		   ;if(var =! 0) var0,temp1
000161 07ac                                      cpc     r26,r28        ; continue digit loop;var1,temp1
000162 f779                                      brne    PC-16          ;/
000163 1734                                      cp      r19,r20        ;Adjust string length (this can be removed for auto-length)temp2,len
000164 f420                                      brcc    PC+5           ;
000165 9533                                      inc     r19            ; temp2
000166 e290                                      ldi     r25,' '        ;var0
000167 939f                                      push    r25            ;var0
000168 cffa                                      rjmp    PC-5           ;/
000169 919f                                      pop     r25            ;Put decimal string var0
00016a d004                                      rcall  xmit            ;<-- Put a char (var0) to memory, console or any display device
00016b 953a                                      dec     r19            ;temp2
00016c f7e1                                      brne    PC-3           ;/
00016d 2744                      				clr r20				   ; clear length for next call
00016e 9508                                      ret					   ; return to caller
                                 xmit:
00016f 9391                      	st Z+,r25						   ; store to SRAM value in r25 , Z pointer set inside binary_decimal routine
000170 9508                      	ret								   ; return to caller
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 
                                 
                                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATtiny10" register use summary:
x  :   0 y  :   6 z  :   2 r0 :   0 r1 :   0 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16:  17 r17:  24 r18:  14 r19:  14 r20:  10 
r21:  15 r22:  10 r23:   4 r24:  13 r25:  27 r26:  12 r27:   6 r28:   5 
r29:   1 r30:   7 r31:   9 
Registers used: 18 out of 35 (51.4%)

"ATtiny10" instruction use summary:
.lds.l:   0 .sts.l:   0 adc   :   2 add   :   1 and   :   0 andi  :   4 
asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 brcc  :   1 
brcs  :   4 breq  :   7 brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 
brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 brne  :  15 brpl  :   0 
brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 
bst   :   0 cbi   :  15 cbr   :   0 clc   :   1 clh   :   0 cli   :   0 
cln   :   0 clr   :  12 cls   :   0 clt   :   0 clv   :   0 clz   :   0 
com   :   2 cp    :   3 cpc   :   1 cpi   :   8 cpse  :   0 dec   :  19 
eor   :   0 icall :   0 ijmp  :   0 in    :   1 inc   :   4 ld    :   7 
ldd   :   0 ldi   :  50 lds   :  14 lsl   :   1 lsr   :   7 mov   :  10 
neg   :   0 nop   :  15 or    :   0 ori   :   1 out   :   2 pop   :   1 
push  :   2 rcall :  69 ret   :  27 reti  :   0 rjmp  :  10 rol   :   2 
ror   :   6 sbc   :   0 sbci  :   1 sbi   :  15 sbic  :   1 sbis  :   0 
sbr   :   0 sbrc  :   1 sbrs  :   1 sec   :   1 seh   :   0 sei   :   0 
sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 sez   :   0 
sleep :   0 st    :   1 std   :   0 sts   :  16 sub   :   1 subi  :   4 
swap  :   0 tst   :   0 wdr   :   0 
Instructions used: 43 out of 99 (43.4%)

"ATtiny10" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0002e2    702     36    738    1024  72.1%
[.dseg] 0x000040 0x000060      0     12     12      32  37.5%
[.eseg] 0x000000 0x000000      0      0      0       0      -

Assembly complete, 0 errors, 21 warnings
