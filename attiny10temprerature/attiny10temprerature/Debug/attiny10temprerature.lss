
AVRASM ver. 2.2.7  C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm Fri May 13 18:36:28 2022

[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATtiny_DFP\1.3.229\avrasm\inc\tn10def.inc'
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(34): warning: Register r28 already defined by the .DEF directive
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(35): warning: Register r29 already defined by the .DEF directive
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(36): warning: Register r27 already defined by the .DEF directive
[builtin](2): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATtiny_DFP\1.3.229\avrasm\inc\tn10def.inc'
                                 
                                 ;
                                 
                                 ;***** Created: 2011-02-09 12:03 ******* Source: ATtiny10.xml ************
                                 ;*************************************************************************
                                 ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
                                 ;* 
                                 ;* Number            : AVR000
                                 ;* File Name         : "tn10def.inc"
                                 ;* Title             : Register/Bit Definitions for the ATtiny10
                                 ;* Date              : 2011-02-09
                                 ;* Version           : 2.35
                                 ;* Support E-mail    : avr@atmel.com
                                 ;* Target MCU        : ATtiny10
                                 ;* 
                                 ;* DESCRIPTION
                                 ;* When including this file in the assembly program file, all I/O register 
                                 ;* names and I/O register bit names appearing in the data book can be used.
                                 ;* In addition, the six registers forming the three data pointers X, Y and 
                                 ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
                                 ;* SRAM is also defined 
                                 ;* 
                                 ;* The Register names are represented by their hexadecimal address.
                                 ;* 
                                 ;* The Register Bit names are represented by their bit number (0-7).
                                 ;* 
                                 ;* Please observe the difference in using the bit names with instructions
                                 ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc"
                                 ;* (skip if bit in register set/cleared). The following example illustrates
                                 ;* this:
                                 ;* 
                                 ;* in    r16,PORTB             ;read PORTB latch
                                 ;* sbr   r16,(1<<PB6)+(1<<PB5) ;set PB6 and PB5 (use masks, not bit#)
                                 ;* out   PORTB,r16             ;output to PORTB
                                 ;* 
                                 ;* in    r16,TIFR              ;read the Timer Interrupt Flag Register
                                 ;* sbrc  r16,TOV0              ;test the overflow flag (use bit#)
                                 ;* rjmp  TOV0_is_set           ;jump if set
                                 ;* ...                         ;otherwise do something else
                                 ;*************************************************************************
                                 
                                 #ifndef _TN10DEF_INC_
                                 #define _TN10DEF_INC_
                                 
                                 
                                 #pragma partinc 0
                                 
                                 ; ***** SPECIFY DEVICE ***************************************************
                                 .device ATtiny10
                                 #pragma AVRPART ADMIN PART_NAME ATtiny10
                                 .equ	SIGNATURE_000	= 0x1e
                                 .equ	SIGNATURE_001	= 0x90
                                 .equ	SIGNATURE_002	= 0x03
                                 
                                 #pragma AVRPART CORE CORE_VERSION AVR8L_0
                                 
                                 
                                 ; ***** I/O REGISTER DEFINITIONS *****************************************
                                 ; NOTE:
                                 ; Definitions marked "MEMORY MAPPED"are extended I/O ports
                                 ; and cannot be used with IN/OUT instructions
                                 .equ	SREG	= 0x3f
                                 .equ	SPL	= 0x3d
                                 .equ	SPH	= 0x3e
                                 .equ	CCP	= 0x3c
                                 .equ	RSTFLR	= 0x3b
                                 .equ	SMCR	= 0x3a
                                 .equ	OSCCAL	= 0x39
                                 .equ	CLKMSR	= 0x37
                                 .equ	CLKPSR	= 0x36
                                 .equ	PRR	= 0x35
                                 .equ	VLMCSR	= 0x34
                                 .equ	NVMCMD	= 0x33
                                 .equ	NVMCSR	= 0x32
                                 .equ	WDTCSR	= 0x31
                                 .equ	GTCCR	= 0x2f
                                 .equ	TCCR0A	= 0x2e
                                 .equ	TCCR0B	= 0x2d
                                 .equ	TCCR0C	= 0x2c
                                 .equ	TIMSK0	= 0x2b
                                 .equ	TIFR0	= 0x2a
                                 .equ	TCNT0L	= 0x28
                                 .equ	TCNT0H	= 0x29
                                 .equ	OCR0AL	= 0x26
                                 .equ	OCR0AH	= 0x27
                                 .equ	OCR0BL	= 0x24
                                 .equ	OCR0BH	= 0x25
                                 .equ	ICR0L	= 0x22
                                 .equ	ICR0H	= 0x23
                                 .equ	ACSR	= 0x1f
                                 .equ	ADCSRA	= 0x1d
                                 .equ	ADCSRB	= 0x1c
                                 .equ	ADMUX	= 0x1b
                                 .equ	ADCL	= 0x19
                                 .equ	DIDR0	= 0x17
                                 .equ	EICRA	= 0x15
                                 .equ	EIFR	= 0x14
                                 .equ	EIMSK	= 0x13
                                 .equ	PCICR	= 0x12
                                 .equ	PCIFR	= 0x11
                                 .equ	PCMSK	= 0x10
                                 .equ	PORTCR	= 0x0c
                                 .equ	PUEB	= 0x03
                                 .equ	PORTB	= 0x02
                                 .equ	DDRB	= 0x01
                                 .equ	PINB	= 0x00
                                 
                                 
                                 ; ***** BIT DEFINITIONS **************************************************
                                 
                                 ; ***** AD_CONVERTER *****************
                                 ; ADMUX - The ADC multiplexer Selection Register
                                 .equ	MUX0	= 0	; Analog Channel Selection Bits
                                 .equ	MUX1	= 1	; Analog Channel Selection Bits
                                 
                                 ; ADCSRA - The ADC Control and Status register A
                                 .equ	ADPS0	= 0	; ADC  Prescaler Select Bits
                                 .equ	ADPS1	= 1	; ADC  Prescaler Select Bits
                                 .equ	ADPS2	= 2	; ADC  Prescaler Select Bits
                                 .equ	ADIE	= 3	; ADC Interrupt Enable
                                 .equ	ADIF	= 4	; ADC Interrupt Flag
                                 .equ	ADATE	= 5	; ADC  Auto Trigger Enable
                                 .equ	ADSC	= 6	; ADC Start Conversion
                                 .equ	ADEN	= 7	; ADC Enable
                                 
                                 ; ADCSRB - The ADC Control and Status register B
                                 .equ	ADTS0	= 0	; ADC Auto Trigger Source bit 0
                                 .equ	ADTS1	= 1	; ADC Auto Trigger Source bit 1
                                 .equ	ADTS2	= 2	; ADC Auto Trigger Source bit 2
                                 
                                 ; ADCL - ADC Data Register
                                 .equ	ADC0	= 0	; ADC Data Register Bit 0
                                 .equ	ADC1	= 1	; ADC Data Register Bit 1
                                 .equ	ADC2	= 2	; ADC Data Register Bit 2
                                 .equ	ADC3	= 3	; ADC Data Register Bit 3
                                 .equ	ADC4	= 4	; ADC Data Register Bit 4
                                 .equ	ADC5	= 5	; ADC Data Register Bit 5
                                 .equ	ADC6	= 6	; ADC Data Register Bit 6
                                 .equ	ADC7	= 7	; ADC Data Register Bit 7
                                 
                                 ; DIDR0 - Digital Input Disable Register
                                 .equ	ADC0D	= 0	; 
                                 .equ	ADC1D	= 1	; 
                                 .equ	ADC2D	= 2	; 
                                 .equ	ADC3D	= 3	; 
                                 
                                 
                                 ; ***** ANALOG_COMPARATOR ************
                                 ; ACSR - Analog Comparator Control And Status Register
                                 .equ	ACIS0	= 0	; Analog Comparator Interrupt Mode Select bit 0
                                 .equ	ACIS1	= 1	; Analog Comparator Interrupt Mode Select bit 1
                                 .equ	ACIC	= 2	; Analog Comparator Input Capture  Enable
                                 .equ	ACIE	= 3	; Analog Comparator Interrupt Enable
                                 .equ	ACI	= 4	; Analog Comparator Interrupt Flag
                                 .equ	ACO	= 5	; Analog Compare Output
                                 .equ	ACD	= 7	; Analog Comparator Disable
                                 
                                 ; DIDR0 - 
                                 .equ	AIN0D	= 0	; AIN0 Digital Input Disable
                                 .equ	AIN1D	= 1	; AIN1 Digital Input Disable
                                 
                                 
                                 ; ***** CPU **************************
                                 ; CCP - Configuration Change Protection
                                 .equ	CCP0	= 0	; Configuration Change Protection bit 0
                                 .equ	CCP1	= 1	; Configuration Change Protection bit 1
                                 .equ	CCP2	= 2	; Configuration Change Protection bit 2
                                 .equ	CCP3	= 3	; Configuration Change Protection bit 3
                                 .equ	CCP4	= 4	; Configuration Change Protection bit 4
                                 .equ	CCP5	= 5	; Configuration Change Protection bit 5
                                 .equ	CCP6	= 6	; Configuration Change Protection bit 6
                                 .equ	CCP7	= 7	; Configuration Change Protection bit 7
                                 
                                 ; SREG - Status Register
                                 .equ	SREG_C	= 0	; Carry Flag
                                 .equ	SREG_Z	= 1	; Zero Flag
                                 .equ	SREG_N	= 2	; Negative Flag
                                 .equ	SREG_V	= 3	; Two's Complement Overflow Flag
                                 .equ	SREG_S	= 4	; Sign Bit
                                 .equ	SREG_H	= 5	; Half Carry Flag
                                 .equ	SREG_T	= 6	; Bit Copy Storage
                                 .equ	SREG_I	= 7	; Global Interrupt Enable
                                 
                                 ; CLKMSR - Clock Main Settings Register
                                 .equ	CLKMS0	= 0	; Clock Main Select Bit 0
                                 .equ	CLKMS1	= 1	; Clock Main Select Bit 1
                                 
                                 ; CLKPSR - Clock Prescale Register
                                 .equ	CLKPS0	= 0	; Clock Prescaler Select Bit 0
                                 .equ	CLKPS1	= 1	; Clock Prescaler Select Bit 1
                                 .equ	CLKPS2	= 2	; Clock Prescaler Select Bit 2
                                 .equ	CLKPS3	= 3	; Clock Prescaler Select Bit 3
                                 
                                 ; OSCCAL - Oscillator Calibration Value
                                 .equ	CAL0	= 0	; Oscillator Calibration Value Bit0
                                 .equ	CAL1	= 1	; Oscillator Calibration Value Bit1
                                 .equ	CAL2	= 2	; Oscillator Calibration Value Bit2
                                 .equ	CAL3	= 3	; Oscillator Calibration Value Bit3
                                 .equ	CAL4	= 4	; Oscillator Calibration Value Bit4
                                 .equ	CAL5	= 5	; Oscillator Calibration Value Bit5
                                 .equ	CAL6	= 6	; Oscillator Calibration Value Bit6
                                 .equ	CAL7	= 7	; Oscillator Calibration Value Bit7
                                 
                                 ; SMCR - Sleep Mode Control Register
                                 .equ	SE	= 0	; Sleep Enable
                                 .equ	SM0	= 1	; Sleep Mode Select Bit 0
                                 .equ	SM1	= 2	; Sleep Mode Select Bit 1
                                 .equ	SM2	= 3	; Sleep Mode Select Bit 2
                                 
                                 ; PRR - Power Reduction Register
                                 .equ	PRTIM0	= 0	; Power Reduction Timer/Counter0
                                 .equ	PRADC	= 1	; Power Reduction ADC
                                 
                                 ; VLMCSR - Vcc Level Monitoring Control and Status Register
                                 .equ	VLM0	= 0	; Trigger Level of Voltage Level Monitor bit 0
                                 .equ	VLM1	= 1	; Trigger Level of Voltage Level Monitor bit 1
                                 .equ	VLM2	= 2	; Trigger Level of Voltage Level Monitor bit 2
                                 .equ	VLMIE	= 6	; VLM Interrupt Enable
                                 .equ	VLMF	= 7	; VLM Flag
                                 
                                 ; RSTFLR - Reset Flag Register
                                 .equ	PORF	= 0	; Power-on Reset Flag
                                 .equ	EXTRF	= 1	; External Reset Flag
                                 .equ	WDRF	= 3	; Watchdog Reset Flag
                                 
                                 ; NVMCSR - Non-Volatile Memory Control and Status Register
                                 .equ	NVMBSY	= 7	; Non-Volatile Memory Busy
                                 
                                 ; NVMCMD - Non-Volatile Memory Command
                                 .equ	NVMCMD0	= 0	; 
                                 .equ	NVMCMD1	= 1	; 
                                 .equ	NVMCMD2	= 2	; 
                                 .equ	NVMCMD3	= 3	; 
                                 .equ	NVMCMD4	= 4	; 
                                 .equ	NVMCMD5	= 5	; 
                                 
                                 
                                 ; ***** PORTB ************************
                                 ; PORTCR - Port Control Register
                                 .equ	BBMB	= 1	; Break-Before-Make Mode Enable
                                 
                                 ; PUEB - Pull-up Enable Control Register
                                 .equ	PUEB0	= 0	; 
                                 .equ	PUEB1	= 1	; 
                                 .equ	PUEB2	= 2	; 
                                 .equ	PUEB3	= 3	; 
                                 
                                 ; PORTB - Input Pins, Port B
                                 .equ	PORTB0	= 0	; 
                                 .equ	PB0	= 0	; For compatibility
                                 .equ	PORTB1	= 1	; 
                                 .equ	PB1	= 1	; For compatibility
                                 .equ	PORTB2	= 2	; 
                                 .equ	PB2	= 2	; For compatibility
                                 .equ	PORTB3	= 3	; 
                                 .equ	PB3	= 3	; For compatibility
                                 
                                 ; DDRB - Data Direction Register, Port B
                                 .equ	DDB0	= 0	; 
                                 .equ	DDB1	= 1	; 
                                 .equ	DDB2	= 2	; 
                                 .equ	DDB3	= 3	; 
                                 
                                 ; PINB - Port B Data register
                                 .equ	PINB0	= 0	; 
                                 .equ	PINB1	= 1	; 
                                 .equ	PINB2	= 2	; 
                                 .equ	PINB3	= 3	; 
                                 
                                 
                                 ; ***** EXTERNAL_INTERRUPT ***********
                                 ; EICRA - External Interrupt Control Register A
                                 .equ	ISC00	= 0	; Interrupt Sense Control 0 Bit 0
                                 .equ	ISC01	= 1	; Interrupt Sense Control 0 Bit 1
                                 
                                 ; EIMSK - External Interrupt Mask register
                                 .equ	INT0	= 0	; External Interrupt Request 0 Enable
                                 
                                 ; EIFR - External Interrupt Flag register
                                 .equ	INTF0	= 0	; External Interrupt Flag 0
                                 
                                 ; PCICR - Pin Change Interrupt Control Register
                                 .equ	PCIE0	= 0	; Pin Change Interrupt Enable 0
                                 
                                 ; PCIFR - Pin Change Interrupt Flag Register
                                 .equ	PCIF0	= 0	; Pin Change Interrupt Flag 0
                                 
                                 ; PCMSK - Pin Change Mask Register
                                 .equ	PCINT0	= 0	; Pin Change Enable Mask 0
                                 .equ	PCINT1	= 1	; Pin Change Enable Mask 1
                                 .equ	PCINT2	= 2	; Pin Change Enable Mask 2
                                 .equ	PCINT3	= 3	; Pin Change Enable Mask 3
                                 
                                 
                                 ; ***** TIMER_COUNTER_0 **************
                                 ; TCCR0A - Timer/Counter 0 Control Register A
                                 .equ	WGM00	= 0	; Waveform Generation Mode
                                 .equ	WGM01	= 1	; Waveform Generation Mode
                                 .equ	COM0B0	= 4	; Compare Output Mode for Channel B bit 0
                                 .equ	COM0B1	= 5	; Compare Output Mode for Channel B bit 1
                                 .equ	COM0A0	= 6	; Compare Output Mode for Channel A bit 0
                                 .equ	COM0A1	= 7	; Compare Output Mode for Channel A bit 1
                                 
                                 ; TCCR0B - Timer/Counter 0 Control Register B
                                 .equ	CS00	= 0	; Clock Select
                                 .equ	CS01	= 1	; Clock Select
                                 .equ	CS02	= 2	; Clock Select
                                 .equ	WGM02	= 3	; Waveform Generation Mode
                                 .equ	WGM03	= 4	; Waveform Generation Mode
                                 .equ	ICES0	= 6	; Input Capture Edge Select
                                 .equ	ICNC0	= 7	; Input Capture Noise Canceler
                                 
                                 ; TCCR0C - Timer/Counter 0 Control Register C
                                 .equ	FOC0B	= 6	; Force Output Compare for Channel B
                                 .equ	FOC0A	= 7	; Force Output Compare for Channel A
                                 
                                 ; TIMSK0 - Timer Interrupt Mask Register 0
                                 .equ	TOIE0	= 0	; Overflow Interrupt Enable
                                 .equ	OCIE0A	= 1	; Output Compare A Match Interrupt Enable
                                 .equ	OCIE0B	= 2	; Output Compare B Match Interrupt Enable
                                 .equ	ICIE0	= 5	; Input Capture Interrupt Enable
                                 
                                 ; TIFR0 - Overflow Interrupt Enable
                                 .equ	TOV0	= 0	; Timer Overflow Flag
                                 .equ	OCF0A	= 1	; Timer Output Compare Flag 0A
                                 .equ	OCF0B	= 2	; Timer Output Compare Flag 0B
                                 .equ	ICF0	= 5	; Input Capture Flag
                                 
                                 ; GTCCR - General Timer/Counter Control Register
                                 .equ	PSR	= 0	; Prescaler Reset
                                 .equ	TSM	= 7	; Timer Synchronization Mode
                                 
                                 
                                 ; ***** WATCHDOG *********************
                                 ; WDTCSR - Watchdog Timer Control and Status Register
                                 .equ	WDP0	= 0	; Watch Dog Timer Prescaler bit 0
                                 .equ	WDP1	= 1	; Watch Dog Timer Prescaler bit 1
                                 .equ	WDP2	= 2	; Watch Dog Timer Prescaler bit 2
                                 .equ	WDE	= 3	; Watch Dog Enable
                                 .equ	WDP3	= 5	; Watchdog Timer Prescaler Bit 3
                                 .equ	WDIE	= 6	; Watchdog Timer Interrupt Enable
                                 .equ	WDIF	= 7	; Watchdog Timer Interrupt Flag
                                 
                                 
                                 
                                 ; ***** LOCKSBITS ********************************************************
                                 .equ	LB1	= 0	; Lockbit
                                 .equ	LB2	= 1	; Lockbit
                                 
                                 
                                 ; ***** FUSES ************************************************************
                                 ; BYTE0 fuse bits
                                 .equ	RSTDISBL	= 0	; Disable external reset
                                 .equ	WDTON	= 1	; Watch dog timer always on
                                 .equ	CKOUT	= 2	; Output external clock
                                 
                                 
                                 
                                 ; ***** CPU REGISTER DEFINITIONS *****************************************
                                 .def	XH	= r27
                                 .def	XL	= r26
                                 .def	YH	= r29
                                 .def	YL	= r28
                                 .def	ZH	= r31
                                 .def	ZL	= r30
                                 
                                 
                                 
                                 ; ***** DATA MEMORY DECLARATIONS *****************************************
                                 .equ	FLASHEND	= 0x01ff	; Note: Word address
                                 .equ	IOEND	= 0x003f
                                 .equ	SRAM_START	= 0x0040
                                 .equ	SRAM_SIZE	= 32
                                 .equ	RAMEND	= 0x005f
                                 .equ	XRAMEND	= 0x0000
                                 .equ	E2END	= 0x0000
                                 .equ	EEPROMEND	= 0x0000
                                 
                                 ; ***** MEMORY MAPPED NVM ************************************************
                                 .equ	MAPPED_FLASH_START	= 0x4000
                                 .equ	MAPPED_LOCKBITS_0	= 0x3f00
                                 .equ	MAPPED_CONFIG_0	= 0x3f40
                                 .equ	MAPPED_CALIB_0	= 0x3f80
                                 .equ	MAPPED_SIGN_0	= 0x3fc0
                                 .equ	MAPPED_SIGN_1	= 0x3fc1
                                 .equ	MAPPED_SIGN_2	= 0x3fc2
                                 .equ	MAPPED_FLASH_SIZE	= 0x0400
                                 .equ	MAPPED_FLASH_END	= 0x43ff
                                 #pragma AVRPART MEMORY PROG_FLASH 1024
                                 #pragma AVRPART MEMORY EEPROM 0
                                 #pragma AVRPART MEMORY INT_SRAM SIZE 32
                                 #pragma AVRPART MEMORY INT_SRAM START_ADDR 0x40
                                 
                                 
                                 
                                 ; ***** BOOTLOADER DECLARATIONS ******************************************
                                 .equ	PAGESIZE	= 16
                                 
                                 
                                 
                                 ; ***** INTERRUPT VECTORS ************************************************
                                 .equ	INT0addr	= 0x0001	; External Interrupt Request 0
                                 .equ	PCI0addr	= 0x0002	; Pin Change Interrupt Request 0
                                 .equ	ICP0addr	= 0x0003	; Timer/Counter0 Input Capture
                                 .equ	OVF0addr	= 0x0004	; Timer/Counter0 Overflow
                                 .equ	OC0Aaddr	= 0x0005	; Timer/Counter Compare Match A
                                 .equ	OC0Baddr	= 0x0006	; Timer/Counter Compare Match B
                                 .equ	ACIaddr	= 0x0007	; Analog Comparator
                                 .equ	WDTaddr	= 0x0008	; Watchdog Time-out
                                 .equ	VLMaddr	= 0x0009	; Vcc Voltage Level Monitor
                                 .equ	ADCCaddr	= 0x000a	; ADC Conversion Complete
                                 
                                 .equ	INT_VECTORS_SIZE	= 11	; size in words
                                 
                                 #pragma AVRPART CORE INSTRUCTIONS_NOT_SUPPORTED break
                                 
                                 #endif  /* _TN10DEF_INC_ */
                                 
                                 ; ***** END OF FILE ******************************************************
                                 
                                 ; attiny10temprerature.asm
                                 ; tested and working
                                 ; Created: 06/04/2022 18:51:56
                                 ; Author : Manama
                                 ; chipset = attiny10
                                 ; Dallas DS18B20 temprature sensor
                                 ; single sensor is used with 5k pullup and direct power supply. SkipROM command is used as only 1 sensor in the bus connected to PB1 of attiny10
                                 ; CRC and ROM is not checked, Only SKIPROM, CONVERT,READSCRATCHPAD commands used. Scratchpad reading terminated after 2 tempraturs registers are read.
                                 ; result dispalyed in ssd1306 OLED with 5x8 font which is very small
                                 ; tested OK	
                                 ;
                                 ;pb0 is SDA
                                 ;pb2 is SCL
                                 ;pb1 is data line for temp sensor
                                 
                                 
                                 
                                 .equ fclk = 1000000
                                 .equ address = 0x78
                                 .equ command = 0x00
                                 .equ data_cmd = 0x40
                                 .equ OLED_INIT_LEN = 12    ; 14 if screen flip is needed , 12 if normal screen
                                 .equ font_length = 5
                                 .def temp = r16
                                 .def data = r17
                                 .def counter = r18
                                 .def array_length = r19
                                 .def array_byte = r20
                                 .def ASCII = r21
                                 .def temp1 = r22
                                 .def posx = r23
                                 .def posy = r24
                                 .def result_low = r28
                                 .def result_high = r29
                                 .def result = r27
                                 
                                 .equ search_rom = 0xf0
                                 .equ read_rom = 0x33
                                 .equ match_rom = 0x55
                                 .equ skip_rom = 0xcc
                                 .equ alarm_search = 0xec
                                 .equ convert = 0x44
                                 .equ write_scratchpad = 0x4e
                                 .equ read_sscratchpad = 0xbe
                                 .equ copy_scratchpad = 0x48
                                 .equ recall_E2 = 0xb8
                                 .equ read_powersupply = 0xb4
                                 
                                 .macro printf
                                 ldi temp,@0
                                 mov ASCII,temp
                                 rcall print
                                 .endm 
                                 
                                 .macro cursor
                                 ldi posy,@0
                                 ldi posx,@1
                                 rcall set_cursor
                                 .endm 
                                 
                                 .macro DALLAS_COMMAND
                                 ldi temp1,@0
                                 rcall ROM_COMMANDS
                                 .endm
                                 
                                 .macro F_COMMANDS
                                 ldi temp1,@0
                                 rcall f_command
                                 .endm
                                 
                                 .macro micros
                                 ldi r26,((@0-10)/3)
                                 rcall delayus
                                 .endm
                                 
                                 .dseg
000040                           PAD: .BYTE 1
000041                           PAD1: .byte 1
000042                           presence: .byte 1
000043                           minussign: .byte 1
000044                           firstdigit: .byte 1
000045                           seconddigit: .byte 1
000046                           thirddigit: .byte 1
000047                           decimal: .byte 1
000048                           firstplace: .byte 1
000049                           secplace: .byte 1
00004a                           thirdplace: .byte 1
00004b                           fourthplace: .byte 1
00004c                           SCRATCHPAD: .byte 2
                                 
                                 
                                 .cseg
                                 reset:
                                 		
000000 d05c                      	rcall i2c_command_write		;call 12c write subriutine
000001 d025                      	rcall OLED_INIT				;call OLED initialization routine
000002 e03c                      	ldi array_length,OLED_INIT_LEN		;length of OLED init array 12 loaded
000003 d063                      	rcall array_read			;call array_read subroutine to send OLED init to display via 12c
000004 d041                      	rcall i2c_stop				;call 12c stop
000005 d0d4                      	rcall clear_OLED			;call OLED screen clear routine. writes 0x00 in all OLED GDRAM address 128*32
000006 e080
000007 e174
000008 d0db                      	cursor 0, 20				;cursor macro is called .2nd line 20th slot
000009 eaee                      	ldi ZL,low((2*T)+0x4000)	;attiny10 doesnt allow direct flash read,should access via SRAM address starting at 0x4000 as per data sheet
00000a e4f1                      	ldi ZH,high((2*T)+0x4000)
00000b d06c                      	rcall ASCII0
00000c e9ec                      	ldi ZL,low((2*E)+0x4000)	;attiny10 doesnt allow direct flash read,should access via SRAM address starting at 0x4000 as per data sheet
00000d e4f1                      	ldi ZH,high((2*E)+0x4000)
00000e d069                      	rcall ASCII0
00000f eae2                      	ldi ZL,low((2*M)+0x4000)	;attiny10 doesnt allow direct flash read,should access via SRAM address starting at 0x4000 as per data sheet
000010 e4f1                      	ldi ZH,high((2*M)+0x4000)
000011 d066                      	rcall ASCII0
000012 eae8                      	ldi ZL,low((2*P)+0x4000)	;attiny10 doesnt allow direct flash read,should access via SRAM address starting at 0x4000 as per data sheet
000013 e4f1                      	ldi ZH,high((2*P)+0x4000)
000014 d063                      	rcall ASCII0
000015 e082
000016 e674
000017 d0cc                      	cursor 2, 100
000018 e9e6                      	ldi ZL,low((2*C)+0x4000)	;attiny10 doesnt allow direct flash read,should access via SRAM address starting at 0x4000 as per data sheet
000019 e4f1                      	ldi ZH,high((2*C)+0x4000)
00001a d05d                      	rcall ASCII0
                                 	
                                 main_loop:
00001b d128                      	rcall measure				; subroutine to read ,convert to decimal and ASCII from DS18B20
00001c e096                      	ldi r25,6					; r25 used as counter for printing ASCII characters stored in SRAM registers begining with minussign, number in r25 decides no of characters max = 9, here loaded 6 to display only 1 decimal position eg 10.1
00001d e4c3                      	ldi YL,low(minussign)		; load Y pointer with SRAM register (minussign)of stored ASCII characters after reading sensor
00001e e0d0                      	ldi YH,high(minussign)
00001f e082
000020 e174
000021 d0c2                      	cursor 2, 20				; set ssd1602 cursor to 3rd line (0,1,2 are lines) 20th position to start printing temprature value
                                 printtemp:
000022 9159                      	ld ASCII,Y+					; load register ASCII with value stored in address pointed by Y , starts from minussign in SRAM
000023 d049                      	rcall print					; call subroutine print to calculate and write the corresponding font from the font table
000024 959a                      	dec r25						; decrease counter
000025 f7e1                      	brne printtemp				; if counter not exhausted loop to label printtemp which will load from next register in SRAM
000026 cff4                      	rjmp main_loop				; repeat this main loop for ever
                                 
                                 
                                 OLED_INIT:
000027 e5e4                      	ldi ZL,low((2*OLED_INIT_BYTES)+0x4000)		;load low value of OLED_INIT_BYTES address to ZL
000028 e4f0                      	ldi ZH,high((2*OLED_INIT_BYTES)+0x4000)		;load high value of OLED_INIT_BYTES address to ZH
000029 9508                      	ret											;return from subroutine
                                 OLED_INIT_BYTES:
00002a 1fa8
00002b 0022
00002c 2003
00002d da00
00002e 8d02
00002f af14
000030 c8a1                      .DB 0xA8,0x1F,0x22,0x00,0x03,0x20,0x00,0xDA,0x02,0x8D,0x14,0xAF,0xA1,0xC8
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                 ;  0xA8, 0x1F,       // set multiplex (HEIGHT-1): 0x1F for 128x32, 0x3F for 128x64 ; 
                                 ;  0x22, 0x00, 0x03, // set min and max page					   ;
                                 ;  0x20, 0x00,       // set horizontal memory addressing mode			   ;
                                 ;  0xDA, 0x02,       // set COM pins hardware configuration to sequential          ;
                                 ;  0x8D, 0x14,       // enable charge pump                                         ;
                                 ;  0xAF,             // switch on OLED                                             ;
                                 ;  0xA1, 0xC8        // flip the screen                                            ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;I2C ROUTINES     register used- temp/data/counter = r16/r17/r18                                                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 sda_low:
000031 9a08                      	sbi ddrb,ddb0			;set ddrb0 making pb0 output, as port is 0 the output will sink causing the SDA line to go low
000032 0000                      	nop						;mini delay
000033 9508                      	ret						; return
                                 
                                 sda_high:
000034 9808                      	cbi ddrb,ddb0			;clear data direction bit of pb0.As port and DDR is 0 the pb0 is tristated and line is pulled high by I2C resistor
000035 0000                      	nop						;delay
000036 9508                      	ret
                                 
                                 scl_low:
000037 9a0a                      	sbi ddrb,ddb2			;set ddrb2 making pb2 output, as port is 0 the output will sink causing the SCK line to go low
000038 0000                      	nop
000039 9508                      	ret
                                 
                                 scl_high:
00003a 980a                      	cbi ddrb,ddb2			;clear data direction bit of pb2.As port and DDR is 0 the pb2 is tristated and line is pulled high by I2C resistor
00003b 0000                      	nop
00003c 9508                      	ret
                                 
                                 i2c_init:
00003d e000                      	ldi temp,0x00			;load 0 in ddr & port to tristate the portB
00003e b901                      	out ddrb,temp			
00003f b902                      	out portb,temp
000040 9508                      	ret
                                 
                                 i2c_start:
000041 dfef                      	rcall sda_low			;I2C start condition needs SDA low before SCL goes low
000042 dff4                      	rcall scl_low
000043 e718                      	ldi data,address		;slave address is copied to data register to initiate communication.integrated with subroutine to reduce code repetition.
000044 d005                      	rcall i2c_write			;write function for i2c
000045 9508                      	ret
                                 
                                 i2c_stop:
000046 dfea                      	rcall sda_low			;I2C needs SCL to go high and then SDA to high to indicate stop transmission.SDA is pulled low to make sure.
000047 dff2                      	rcall scl_high
000048 dfeb                      	rcall sda_high
000049 9508                      	ret
                                 
                                 i2c_write:
00004a e028                      	ldi counter,0x08		;counter is loaded 8 as we send 8 bits.counter is decreased after sending each bit and completes transmission at 0
                                 loop:
00004b dfe5                      	rcall sda_low			;SDA is kept low and only made high if the read bit is 1
00004c 2f01                      	mov temp,data			;copy data byte to temp
00004d 7800                      	andi temp,0x80			;AND copied value with 0b10000000.If 7th bit is one the register holds the same value or register becomes 0
00004e fd07                      	sbrc temp,7				;If 7th bit is 0 skip next instruction
00004f dfe4                      	rcall sda_high			;call SDA high function if AND result was a 1 in 7th bit in TEMP register
000050 0000                      	nop						;delay
000051 dfe8                      	rcall scl_high			;call SCL high to clock the data.data is transmitted when the clock is cycled high to low while SDA is held stable at 0 or 1
000052 0f11                      	lsl data				;shift data register left to check the next bit
000053 dfe3                      	rcall scl_low			;call SCL low function to complete the clocking
000054 952a                      	dec counter				;decrease the counter which indicates how many bits left
000055 f7a9                      	brne loop				;loop back through the process again until counter is 0
000056 dfdd                      	rcall sda_high			;release SDA line for receiving the ACK from slave
000057 dfe2                      	rcall scl_high			;call SCL to send 9th pulse and wait for ACK
000058 0000                      	nop						; delay
000059 0000                      	nop						;delay
00005a dfdc                      	rcall scl_low			;ready for continuation of data transfer unless a stop is called
00005b dfd5                      	rcall sda_low
00005c 9508                      	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;I2C_COMMAND_WRITE  ;function to write a stream of commands to the OLED
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 i2c_command_write:
00005d dfdf                      	rcall i2c_init			;
00005e dfe2                      	rcall i2c_start
00005f e010                      	ldi data,command		;command value is 0x00
000060 dfe9                      	rcall i2c_write
000061 9508                      	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;I2C_DATA_WRITE	  ;function to write a stream of data to the OLED
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 i2c_data_write:
000062 dfda                      	rcall i2c_init
000063 dfdd                      	rcall i2c_start
000064 e410                      	ldi data,data_cmd			;data command is 0x40
000065 dfe4                      	rcall i2c_write
000066 9508                      	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;ARRAY READ FUNCTION registers-r19/r20 ;array_length = r19,array_byte = r20 
                                 ;dependency = use ldi array_length,( number of bytes ) prior to rcall array_read
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 array_read:
                                 loop1:
000067 9141                      	ld array_byte,Z+
000068 2f14                      	mov data,array_byte
000069 dfe0                      	rcall i2c_write
00006a 953a                      	dec array_length
00006b f7d9                      	brne loop1
00006c 9508                      	ret
                                 
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;PRINT function   uses registers- temp1,temp,array_byte,ASCII,array_length
                                 ;characters to be printed has to be passed into register ASCII as ASCII values
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 print:
00006d efea                      	ldi ZL,low((2*fonts)+0x4000)	;attiny10 doesnt allow direct flash read,should access via SRAM address starting at 0x4000 as per data sheet
00006e e4f0                      	ldi ZH,high((2*fonts)+0x4000)
00006f e240                      	ldi array_byte,0x20   			;hex value of first ASCII caharacter in font aray is 0x20 .subtract start value from ASCII value returned from ASCII_CONVERTER to know the position of character in the array
000070 1b54                      	sub ASCII,array_byte			;result of subtraction will be position of first byte of the character
000071 f031                      	breq ASCII0						;if the result is 0 go to label ASCII0 and print 6 bytes which is a space (0x20 = space in the font array,1st character)
000072 2700                      	clr temp						;clear temp for counting
                                 ;ldi temp1,0x00						;clear temp1 for subtraction (ithink this was for 0 carry propogation)
                                 multiply:
000073 5fea                      	subi r30,low(-6)				;adding immediate not suppported. immediate extends beyond 8bit.using subi & sbci with -ve number will do & loading with hi &lo will propogate carry.
000074 4fff                      	sbci r31,high(-6)
000075 9503                      	inc temp						;counter increased on each iteration
000076 1705                      	cp temp,ASCII					;counter is compared to value in ASCII register(start address of the array row)
000077 f7d9                      	brne multiply					;if the atart address not reached loop back through the code from label "multiply"
                                 ASCII0:
000078 dfe9                      	rcall i2c_data_write			;call function to initiate data write which will transmit data write command before transfer of data array
000079 e036                      	ldi array_length,6				;specify array length of 6 as six bytes make 1 character.5 as in the array below and as mentioned above 0 padded by assembler. if stored bytes are not even assembler will add 0 byte to align code
00007a dfec                      	rcall array_read				;call array read function which writes the bytes 1 after another in a sequence which ahs i2c write function included
00007b dfca                      	rcall i2c_stop					;stop i2c transfer
00007c 9508                      	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;FONTS   fonts below 5bytes ,assembler will add one byte of padding with 0. hence array lenth =6
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 fonts:
00007d 0000
00007e 0000
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(277): warning: .cseg .db misalignment - padding zero byte
00007f 0000                      .db 0x00, 0x00, 0x00, 0x00, 0x00 //sp 0  0x20
000080 0000
000081 002f
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(278): warning: .cseg .db misalignment - padding zero byte
000082 0000                      .DB 0x00, 0x00, 0x2f, 0x00, 0x00 // ! 1  0x21
000083 0700
000084 0700
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(279): warning: .cseg .db misalignment - padding zero byte
000085 0000                      .DB 0x00, 0x07, 0x00, 0x07, 0x00 // " 2  0x22
000086 7f14
000087 7f14
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(280): warning: .cseg .db misalignment - padding zero byte
000088 0014                      .DB 0x14, 0x7f, 0x14, 0x7f, 0x14 // # 3  0x23
000089 2a24
00008a 2a7f
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(281): warning: .cseg .db misalignment - padding zero byte
00008b 0012                      .DB 0x24, 0x2a, 0x7f, 0x2a, 0x12 // $ 4  0x24
00008c 6462
00008d 1308
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(282): warning: .cseg .db misalignment - padding zero byte
00008e 0023                      .DB 0x62, 0x64, 0x08, 0x13, 0x23 // % 5  0x25
00008f 4936
000090 2255
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(283): warning: .cseg .db misalignment - padding zero byte
000091 0050                      .DB 0x36, 0x49, 0x55, 0x22, 0x50 // & 6  0x26
000092 0500
000093 0003
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(284): warning: .cseg .db misalignment - padding zero byte
000094 0000                      .DB 0x00, 0x05, 0x03, 0x00, 0x00 // ' 7  0x27
000095 1c00
000096 4122
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(285): warning: .cseg .db misalignment - padding zero byte
000097 0000                      .DB 0x00, 0x1c, 0x22, 0x41, 0x00 // ( 8  0x28
000098 4100
000099 1c22
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(286): warning: .cseg .db misalignment - padding zero byte
00009a 0000                      .DB 0x00, 0x41, 0x22, 0x1c, 0x00 // ) 9  0x29
00009b 0814
00009c 083e
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(287): warning: .cseg .db misalignment - padding zero byte
00009d 0014                      .DB 0x14, 0x08, 0x3E, 0x08, 0x14 // * 10 0x2A
00009e 0808
00009f 083e
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(288): warning: .cseg .db misalignment - padding zero byte
0000a0 0008                      .DB 0x08, 0x08, 0x3E, 0x08, 0x08 // + 11 0x2B
0000a1 0000
0000a2 60a0
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(289): warning: .cseg .db misalignment - padding zero byte
0000a3 0000                      .DB 0x00, 0x00, 0xA0, 0x60, 0x00 // , 12 0x2C
0000a4 0808
0000a5 0808
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(290): warning: .cseg .db misalignment - padding zero byte
0000a6 0008                      .DB 0x08, 0x08, 0x08, 0x08, 0x08 // - 13 0x2D
0000a7 6000
0000a8 0060
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(291): warning: .cseg .db misalignment - padding zero byte
0000a9 0000                      .DB 0x00, 0x60, 0x60, 0x00, 0x00 // . 14 0x2E
0000aa 1020
0000ab 0408
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(292): warning: .cseg .db misalignment - padding zero byte
0000ac 0002                      .DB 0x20, 0x10, 0x08, 0x04, 0x02 // / 15 0x2F
0000ad 513e
0000ae 4549
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(293): warning: .cseg .db misalignment - padding zero byte
0000af 003e                      .DB 0x3E, 0x51, 0x49, 0x45, 0x3E // 0 16 0x30
0000b0 4200
0000b1 407f
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(294): warning: .cseg .db misalignment - padding zero byte
0000b2 0000                      .DB 0x00, 0x42, 0x7F, 0x40, 0x00 // 1 17 0x31
0000b3 6142
0000b4 4951
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(295): warning: .cseg .db misalignment - padding zero byte
0000b5 0046                      .DB 0x42, 0x61, 0x51, 0x49, 0x46 // 2 18 0x32
0000b6 4121
0000b7 4b45
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(296): warning: .cseg .db misalignment - padding zero byte
0000b8 0031                      .DB 0x21, 0x41, 0x45, 0x4B, 0x31 // 3 19 0x33
0000b9 1418
0000ba 7f12
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(297): warning: .cseg .db misalignment - padding zero byte
0000bb 0010                      .DB 0x18, 0x14, 0x12, 0x7F, 0x10 // 4 20 0x34
0000bc 4527
0000bd 4545
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(298): warning: .cseg .db misalignment - padding zero byte
0000be 0039                      .DB 0x27, 0x45, 0x45, 0x45, 0x39 // 5 21 0x35
0000bf 4a3c
0000c0 4949
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(299): warning: .cseg .db misalignment - padding zero byte
0000c1 0030                      .DB 0x3C, 0x4A, 0x49, 0x49, 0x30 // 6 22 0x36
0000c2 7101
0000c3 0509
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(300): warning: .cseg .db misalignment - padding zero byte
0000c4 0003                      .DB 0x01, 0x71, 0x09, 0x05, 0x03 // 7 23 0x37
0000c5 4936
0000c6 4949
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(301): warning: .cseg .db misalignment - padding zero byte
0000c7 0036                      .DB 0x36, 0x49, 0x49, 0x49, 0x36 // 8 24 0x38
0000c8 4906
0000c9 2949
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(302): warning: .cseg .db misalignment - padding zero byte
0000ca 001e                      .DB 0x06, 0x49, 0x49, 0x29, 0x1E // 9 25 0x39
                                 /*
                                 .DB 0x00, 0x36, 0x36, 0x00, 0x00 // : 26 0x3A
                                 .DB 0x00, 0x56, 0x36, 0x00, 0x00 // ; 27 0x3B
                                 .DB 0x08, 0x14, 0x22, 0x41, 0x00 // < 28 0X3C
                                 .DB 0x14, 0x14, 0x14, 0x14, 0x14 // = 29 0X3D
                                 .DB 0x00, 0x41, 0x22, 0x14, 0x08 // > 30 0X3E
                                 .DB 0x02, 0x01, 0x51, 0x09, 0x06 // ? 31 0X3F
                                 .DB 0x32, 0x49, 0x59, 0x51, 0x3E // @ 32 0X40
                                 .DB 0x7C, 0x12, 0x11, 0x12, 0x7C // A 33 0X41
                                 .DB 0x7F, 0x49, 0x49, 0x49, 0x36 // B 34 0X42
                                 */
                                 C:
0000cb 413e
0000cc 4141
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(315): warning: .cseg .db misalignment - padding zero byte
0000cd 0022                      .DB 0x3E, 0x41, 0x41, 0x41, 0x22 // C 35 0X43
                                 ;.DB 0x7F, 0x41, 0x41, 0x22, 0x1C // D 36 0X44
                                 E:
0000ce 497f
0000cf 4949
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(318): warning: .cseg .db misalignment - padding zero byte
0000d0 0041                      .DB 0x7F, 0x49, 0x49, 0x49, 0x41 // E 37 0X45
                                 /*
                                 .DB 0x7F, 0x09, 0x09, 0x09, 0x01 // F 38 0X46
                                 .DB 0x3E, 0x41, 0x49, 0x49, 0x7A // G 39 0X47
                                 .DB 0x7F, 0x08, 0x08, 0x08, 0x7F // H 40 0X48
                                 .DB 0x00, 0x41, 0x7F, 0x41, 0x00 // I 41 0X49
                                 .DB 0x20, 0x40, 0x41, 0x3F, 0x01 // J 42 0X4A
                                 .DB 0x7F, 0x08, 0x14, 0x22, 0x41 // K 43 0X4B
                                 .DB 0x7F, 0x40, 0x40, 0x40, 0x40 // L 44 0X4C
                                 */
                                 M:
0000d1 027f
0000d2 020c
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(329): warning: .cseg .db misalignment - padding zero byte
0000d3 007f                      .DB 0x7F, 0x02, 0x0C, 0x02, 0x7F // M 45 0X4D
                                 ;.DB 0x7F, 0x04, 0x08, 0x10, 0x7F // N 46 0X4E
                                 ;.DB 0x3E, 0x41, 0x41, 0x41, 0x3E // O 47 0X4F
                                 P:
0000d4 097f
0000d5 0909
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(333): warning: .cseg .db misalignment - padding zero byte
0000d6 0006                      .DB 0x7F, 0x09, 0x09, 0x09, 0x06 // P 48 0X50
                                 /*
                                 .DB 0x3E, 0x41, 0x51, 0x21, 0x5E // Q 49 0X51
                                 .DB 0x7F, 0x09, 0x19, 0x29, 0x46 // R 50 0X52
                                 .DB 0x46, 0x49, 0x49, 0x49, 0x31 // S 51 0X53
                                 */
                                 T:
0000d7 0101
0000d8 017f
C:\Users\Manama\Documents\Atmel Studio\7.0\attiny10temprerature\attiny10temprerature\main.asm(340): warning: .cseg .db misalignment - padding zero byte
0000d9 0001                      .DB 0x01, 0x01, 0x7F, 0x01, 0x01 // T 52 0X54
                                 /*
                                 .DB 0x3F, 0x40, 0x40, 0x40, 0x3F // U 53 0X55
                                 .DB 0x1F, 0x20, 0x40, 0x20, 0x1F // V 54 0X56
                                 .DB 0x3F, 0x40, 0x38, 0x40, 0x3F // W 55 0X57
                                 .DB 0x63, 0x14, 0x08, 0x14, 0x63 // X 56 0X58
                                 .DB 0x07, 0x08, 0x70, 0x08, 0x07 // Y 57 0X59
                                 .DB 0x61, 0x51, 0x49, 0x45, 0x43 // Z 58 0X5A
                                 .DB 0x00, 0x7F, 0x41, 0x41, 0x00 // [ 59 0X5B
                                 .DB 0x02, 0x04, 0x08, 0x10, 0x20 // \ 60 0X5C
                                 .DB 0x00, 0x41, 0x41, 0x7F, 0x00 // ] 61 0X5D
                                 .DB 0x04, 0x02, 0x01, 0x02, 0x04 // ^ 62 0X5E
                                 .DB 0x40, 0x40, 0x40, 0x40, 0x40  // _ 63 0X5F
                                 */
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;CLEAR_OLED     registers array_byte/array_length used  writes 128*4 0's to OLED, subroutine to clear whole screen ,write 0
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 clear_OLED:
0000da e044                      	ldi array_byte,4
0000db df86                      	rcall i2c_data_write
                                 loop3:
0000dc e830                      	ldi array_length,128
                                 loop4:
0000dd e010                      	ldi data,0x00
0000de df6b                      	rcall i2c_write
0000df 953a                      	dec array_length
0000e0 f7e1                      	brne loop4
                                 loop5:
0000e1 954a                      	dec array_byte
0000e2 f7c9                      	brne loop3
0000e3 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;SET_ROW   uses register y/x /temp   r24/r23/r16
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 set_cursor:
                                 ;;;;;;;;;;;;;;;;;
                                 ;set_row        
                                 ;;;;;;;;;;;;;;;;;
0000e4 df78                      	rcall i2c_command_write
0000e5 e212                      	ldi data, 0x22			;oled command to set row
0000e6 df63                      	rcall i2c_write
0000e7 2f18                      	mov data,posy			;row value in posY supplied to macro
0000e8 df61                      	rcall i2c_write
0000e9 e013                      	ldi data,0x03			;row end - can be 1 ,2,3. we choose last page 3
0000ea df5f                      	rcall i2c_write
                                 ;;;;;;;;;;;;;;;;
                                 ;set_column    
                                 ;;;;;;;;;;;;;;;;
0000eb e211                      	ldi data, 0x21			;oled command to set column
0000ec df5d                      	rcall i2c_write
0000ed 2f17                      	mov data,posx			;column value in posx supplied to macro
0000ee df5b                      	rcall i2c_write
0000ef e71f                      	ldi data,0x7f			;column begins at 0 to 127 as end in each row. we will choose column end as 127=0x7f
0000f0 df59                      	rcall i2c_write
0000f1 df54                      	rcall i2c_stop
0000f2 9508                      	ret
                                 
                                 
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;* Integer to ASCII converter subrountine here ,r26:r25    r17:r16 is the input registers
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ; Universal decimal string conversion (8/16 bit unsigned)
                                 ;
                                 ; Register Variables:
                                 ;  Call:   r26:r25  = 16 bit value to be converted r26:r25
                                 ;          r20     = final String length r20
                                 ;          r28:r27  = <Don't care> (high register must be assigned)r28:r27 temp registers
                                 ;          r19    = <Don't care>r19
                                 ;
                                 ;  Result: r26:r25  = <Unknown>
                                 ;          len     = <Not changed>
                                 ;          r28:r27  = <Unknown>
                                 ;          r19    = 0
                                 ;
                                 ; ; Stack: 10 bytes max (+output routine)
                                 ;
                                 ; Examples:   var1    len    output
                                 ;              100      0    "100"
                                 ;             1234      0    "1234"
                                 ;                0      7    "      0"
                                 ;              100      5    "  100"
                                 ;              100      2    "100"
                                 ;mk_decu8:       clr     var1            ;8 bit entry
                                 ascii_convert:                         ;16 bit entry
                                 				
0000f3 2733                                      clr     r19            ;digit counter 
0000f4 9533                                      inc     r19            ;---- decimal string generating 
0000f5 27bb                                      clr     r27            ;var1 /= 10; temp0
0000f6 e1c0                                      ldi     r28,16         ; temp1
0000f7 0f99                                      lsl     r25            ;var0
0000f8 1faa                                      rol     r26            ;var1
0000f9 1fbb                                      rol     r27            ;temp0
0000fa 30ba                                      cpi     r27,10         ;temp0
0000fb f010                                      brcs    PC+3            ;
0000fc 50ba                                      subi    r27,10         ;temp0
0000fd 9593                                      inc     r25            ;var0
0000fe 95ca                                      dec     r28            ;temp1
0000ff f7b9                                      brne    PC-8            ;/
000100 5db0                                      subi    r27,-'0'       ;Push the remainder (a decimal digit when added with 0x30 ASCII)
000101 93bf                                      push    r27            ;/temp0
000102 179c                                      cp      r25,r28       ;if(var =! 0) var0,temp1
000103 07ac                                      cpc     r26,r28       ; continue digit loop;var1,temp1
000104 f779                                      brne    PC-16           ;/
000105 1734                                      cp      r19,r20        ;Adjust string length (this can be removed for auto-length)temp2,len
000106 f420                                      brcc    PC+5            ;
000107 9533                                      inc     r19            ; temp2
000108 e290                                      ldi     r25,' '        ;var0
000109 939f                                      push    r25            ;var0
00010a cffa                                      rjmp    PC-5            ;/
00010b 919f                                      pop     r25            ;Put decimal string var0
00010c d004                                      rcall  xmit            ;<-- Put a char (var0) to memory, console or any display device
00010d 953a                                      dec     r19            ;temp2
00010e f7e1                                      brne    PC-3            ;/
00010f 2744                      				clr r20					; clear length for next call
000110 9508                                      ret
                                 xmit:
000111 9391                      	st Z+,r25
000112 9508                      	ret
                                 
                                 
                                 
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;;;calc_fraction multiplies the LSB nibble with scaled value of 625 to get decimal value of fraction, each bit of DS18B20 fraction is weighted 0.0625 degree C
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 calc_fraction:
000113 27ff                      	clr r31					; clear r31 used for carry propagation in multibyte addition
000114 e741                      	ldi r20,low(625)		; load r20 with 625 (scaled value of 0.0625 degC), we multiply with 625 and place decimal point in the LCD between fraction and main
000115 e052                      	ldi r21,high(625)		; load r20 with 625 (scaled value of 0.0625 degC)
000116 2f64                      	mov r22,r20				; copy the 625 so that it can be added to itself , total added value in R23:r22
000117 2f75                      	mov r23,r21				; copy the 625 so that it can be added to itself , total added value in R23:r22
000118 3031                      	cpi r19,1				; check if fraction value of the result copied to r19 in binary_decimal subroutine is equal to 1
000119 f041                      	breq getout				; if 1 branch to label getout as no multiplication is needed and least value of 0.0625 is already in regiser
00011a 3030                      	cpi r19,0				; check if value of fraction in r19 is 0 , if 0 no multiplication needed just clear registers and exit
00011b f049                      	breq clrnexit			; if 0 branch to label clrnexit 
00011c 953a                      	dec r19					; if r19 not 1 or 0 we reach here, decrease 1 from r19 as 625 is already loaded, we need to multiply 1 time less
                                 fmultiply:
00011d 0f64                      	add r22,r20				; add 625 to 625
00011e 1f75                      	adc r23,r21				; add with carry
00011f 1f8f                      	adc r24,r31				; add with carry
000120 953a                      	dec r19					; deecrease r19 after each addition
000121 f7d9                      	brne fmultiply			; if r19 not reached 0 loop back to fmultiply label till all additions have finished
                                 getout:
000122 2744                      	clr r20					; clear registers 625 is in r22, we reach here if r19 was 1 = 0.0625 * 1
000123 2755                      	clr r21					; clear registers 625 is in r22, we reach here if r19 was 1 = 0.0625 * 1
000124 9508                      	ret						; result in r24:r23:R22
                                 clrnexit:
000125 2777                      	clr r23					; clear register as there is no fraction , we reach here if r19 was 0 = no fraction, result whole number
000126 2766                      	clr r22					; clear register as there is no fraction , we reach here if r19 was 0 = no fraction, result whole number
000127 9508                      	ret						; result in r24:r23:R22
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;f_command    sends function commands to ds18b20 cll with macro , ROM_COMMANDS  sends rom commands to ds18b20 call with macro
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 f_command:
000128 e098                      	ldi r25,8				; load counter value 8 (byte )
000129 2f86                      	mov r24,r22				; copy command value from macro register r22
                                 loop51:
00012a 9586                      	lsr r24					; shift right r24 ,lsb now in carry, maxim protocol transmits lsbit first
00012b f020                      	brcs high2				; branch to high2 label if carry flag set , if bit is 1 carry flag is set else carry will 0
00012c d045                      	rcall write0			; if bit was 0 in previous step call routine to write 0 to DS18b20 
00012d 959a                      	dec r25					; decrease counter
00012e f7d9                      	brne loop51				; if counter not reach 0 loop back to label loop51 till all bits are transmitted
00012f 9508                      	ret
                                 high2:
000130 d039                      	rcall write1			; reach here if carry is set , call subroutine to write 1 to ds18b20
000131 959a                      	dec r25					; decrease counter
000132 f7b9                      	brne loop51				; if counter not reach 0 loop back to label loop51 till all bits are transmitted
000133 9508                      	ret
                                 
                                 ROM_COMMANDS:
000134 e098                      	ldi r25,8				; load counter value 8 (byte )
000135 d027                      	rcall dallas_init		; call ds18b20 initialisation routine
000136 a102                      	lds r16,presence		; check response value stored in sram to find out sensor responded or not
000137 3000                      	cpi r16,0				; if sensor not responded exit
000138 f451                      	brne exit0				; if above condition true exit routine (sensor faulty)
000139 2f86                      	mov r24,r22				; copy command value from macro register r22
                                 loop41:
00013a 9586                      	lsr r24					; shift right r24 ,lsb now in carry, maxim protocol transmits lsbit first
00013b f020                      	brcs high1				; branch to high2 label if carry flag set , if bit is 1 carry flag is set else carry will 0
00013c d035                      	rcall write0			; if bit was 0 in previous step call routine to write 0 to DS18b20
00013d 959a                      	dec r25					; decrease counter
00013e f7d9                      	brne loop41				; if counter not reach 0 loop back to label loop41 till all bits are transmitted
00013f 9508                      	ret
                                 high1:
000140 d029                      	rcall write1			; reach here if carry is set , call subroutine to write 1 to ds18b20
000141 959a                      	dec r25					; decrease counter
000142 f7b9                      	brne loop41				; if counter not reach 0 loop back to label loop51 till all bits are transmitted
000143 9508                      exit0:	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 measure:
000144 9811                      	cbi portb,portb1			;pin porta 2 is pulled down by clearing port register
000145 d017                      	rcall dallas_init			; call ds18b20 initialisation
000146 ec6c
000147 dfec                      	DALLAS_COMMAND skip_rom		; call macro to send rom command skip_rom
000148 e464
000149 dfde                      	F_COMMANDS convert			; call macro to send convert function command
                                 	
                                 check1:
00014a d049                      	rcall bit_read				; call bit read subroutine, checks/reads a single bit from 18b20 , if read 1 sensor busy , if read 0 result ready
00014b ff87                      	sbrs r24,7					; if read 1 sensor result ready , if read 1 result ready , read bit is shifted to msb of r24 so set = 1 clear = 0
00014c cffd                      	rjmp check1					; if 0 loop to label check1 till  1 is read from sensor (wit till conversion is complete)
00014d d00f                      	rcall dallas_init			; call ds18b20 initialisation
00014e ec6c
00014f dfe4                      	DALLAS_COMMAND skip_rom		; call macro to send rom command skip_rom
000150 eb6e
000151 dfd6                      	F_COMMANDS read_sscratchpad	; call macro to send read_sscratchpad function command
000152 d025                      	rcall byte_read				; call byte read subroutine to reear sratch pad of the sensor , reads each byte and copies it to SRAM
000153 a98d                      	sts SCRATCHPAD + 1, r24
000154 d023                      	rcall byte_read
000155 a98c                      	sts SCRATCHPAD , r24
000156 0000                      	nop
000157 d005                      	rcall dallas_init
000158 d041                      	rcall binary_decimal
000159 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 delayus:
00015a 95aa                      	dec r26				; call & ret = 9cs, dec =1 ,brne =2 
00015b f7f1                      	brne delayus
00015c 9508                      	ret
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 dallas_init:
00015d 9a09                      	sbi ddrb,ddb1		;porta 2 is output by setting direction register
00015e e9ac
00015f dffa                      	micros 480			;minimum time pull down time required for reset
000160 9809                      	cbi ddrb,ddb1		;change PA2 to input to verify whether DS1B20 pulls the line low to indicate presence
000161 e1a4
000162 dff7                      	micros 70			;sensor should respond after 60 seconds ,so wait for the minimum time
000163 b100                      	in r16,PINB			;copy the PA2 PIN value from PORTA_PIN register
000164 7002                      	andi r16,0b00000010	;AND with 0x04 the value of r16 ,if 0 sensor responded , if 1 no response at the time of checking
000165 a902                      	sts presence,r16	;copy value to memory
000166 e8a5
000167 dff2                      	micros 410			; wait for the remaining time slot of 460 us
000168 0000                      	nop
000169 9508                      	ret
                                 
                                 write1:
00016a 9a09                      	sbi ddrb,ddb1		;porta 2 is output by setting direction register
00016b 0000                      	nop					;delay of 3us data line stays low for more than minimum required time
00016c 0000                      	nop
00016d 0000                      	nop
00016e 9809                      	cbi ddrb,ddb1		;data line released by clearing direction register bit. line is pulled up by pullup voltage
00016f e1a2
000170 dfe9                      	micros 64			;The delay of 60us to finish the time slot as per data sheet
000171 9508                      	ret
                                 
                                 write0:
000172 9a09                      	sbi ddrb,ddb1	;porta 2 is output by setting direction register
000173 e1a0
000174 dfe5                      	micros 60			;delay 60us
000175 9809                      	cbi ddrb,ddb1		;data line released by clearing direction register bit. line is pulled up by pullup voltage
000176 d022                      	rcall us10
000177 9508                      	ret
                                 
                                 byte_read:
000178 e098                      	ldi r25,8
000179 2788                      	clr r24
                                 loopread:
00017a 9a09                      	sbi ddrb,ddb1		;porta 2 is output by setting direction register
00017b 0000                      	nop					;delay of minimum 1 us as per data sheet
00017c 0000                      	nop
00017d 0000                      	nop
00017e 9809                      	cbi ddrb,ddb1		;clear direction register to release data line and turn the master to input
00017f 0000                      	nop
000180 0000                      	nop
000181 0000                      	nop
000182 0000                      	nop
000183 0000                      	nop
000184 9901                      	sbic pinb,pinb1 
000185 c007                      	rjmp one			;if not 0 branch to label one
000186 9488                      	clc					;clear carry bit in SREG
000187 9587                      	ror r24				;rotate right through carry (0 is shifted into msb of r20 from carry,ds18B20 transmits lsb of LSBYTE firt.At the end the first bit in MSB reaches LSB
000188 e0af
000189 dfd0                      	micros 55			;wait for the remaining time slot of the read bit
00018a 959a                      	dec r25				;decrease counter
00018b f771                      	brne loopread			;if counter not 0 branch back to loop3
00018c 9508                      	ret
                                 one:
00018d 9408                      	sec					;set carry bit in SREG
00018e 9587                      	ror r24				;rotate through carry and the carry bit1 will be shifted to MSB of r20 , bit7 >>>>>>> bit0
00018f e0af
000190 dfc9                      	micros 55			;wait for the remaining time slot of the read bit
000191 959a                      	dec r25				; counter	;wait for the remaining time slot of the read bit
000192 f739                      	brne loopread			;if counter not 0 branch back to loop3
000193 9508                      	ret
                                 
                                 bit_read:
000194 e091                      	ldi r25,1
000195 2788                      	clr r24
000196 dfe3                      	rcall loopread
000197 7880                      	andi r24,0x80
000198 9508                      	ret
                                 
                                 us10:
000199 9508                      	ret
                                 
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 ;
                                 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                 
                                 binary_decimal:
00019a e20e                      	ldi r16,'.'
00019b a907                      	sts decimal,r16
00019c a11d                      	lds r17,SCRATCHPAD + 1
00019d a12c                      	lds r18,SCRATCHPAD 
00019e fd27                      	sbrc r18,7
00019f c006                      	rjmp negativeresult
0001a0 e200                      	ldi r16,0x20
0001a1 a903                      	sts minussign,r16
0001a2 2f31                      	mov r19,r17
0001a3 703f                      	andi r19,0x0f
0001a4 df6e                      	rcall calc_fraction
0001a5 c00d                      	rjmp maindigits
                                 negativeresult:
0001a6 2733                      	clr r19
0001a7 a11d                      	lds r17,SCRATCHPAD + 1
0001a8 a12c                      	lds r18,SCRATCHPAD 
0001a9 9520                      	com r18
0001aa 9510                      	com r17
0001ab 5f1f                      	subi r17,-1
                                 ;	sbci r18,0
0001ac 2f31                      	mov r19,r17
0001ad a91d                      	sts  SCRATCHPAD + 1,r17
0001ae a92c                      	sts	 SCRATCHPAD ,r18
0001af 703f                      	andi r19,0x0f
0001b0 e20d                      	ldi r16,'-'
0001b1 a903                      	sts minussign,r16
0001b2 df60                      	rcall calc_fraction
                                 			
                                 maindigits:
0001b3 2f96                      	mov r25,r22					; copy fmultiply results to r26:r25 for ASCII conversion
0001b4 2fa7                      	mov r26,r23					; copy fmultiply results to r26:r25 for ASCII conversion
0001b5 e4e8                      	ldi ZL,low(firstplace)
0001b6 e0f0                      	ldi ZH,high(firstplace)
0001b7 e044                      	ldi r20,4					; length of string 4 as we dont want space loaded at 4th position if leading zero in decimal fraction
0001b8 df3a                      	rcall ASCII_CONVERT
0001b9 a11d                      	lds r17,SCRATCHPAD + 1
0001ba a12c                      	lds r18,SCRATCHPAD 
0001bb 9526                      	lsr r18
0001bc 9517                      	ror r17
0001bd 9526                      	lsr r18
0001be 9517                      	ror r17
0001bf 9526                      	lsr r18
0001c0 9517                      	ror r17
0001c1 9526                      	lsr r18
0001c2 9517                      	ror r17
0001c3 2f91                      	mov r25,r17
0001c4 2fa2                      	mov r26,r18
0001c5 e4e4                      	ldi ZL,low(firstdigit)
0001c6 e0f0                      	ldi ZH,high(firstdigit)
0001c7 e043                      	ldi r20,3
0001c8 df2a                      	rcall ASCII_CONVERT
0001c9 9508                      	ret
                                 


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATtiny10" register use summary:
x  :   0 y  :   1 z  :   2 r0 :   0 r1 :   0 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   0 
r13:   0 r14:   0 r15:   0 r16:  20 r17:  26 r18:  13 r19:  19 r20:  14 
r21:   7 r22:  10 r23:   8 r24:  17 r25:  21 r26:  12 r27:   6 r28:   5 
r29:   1 r30:  10 r31:  12 
Registers used: 18 out of 35 (51.4%)

"ATtiny10" instruction use summary:
.lds.l:   0 .sts.l:   0 adc   :   2 add   :   1 and   :   0 andi  :   5 
asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 brcc  :   1 
brcs  :   3 breq  :   3 brge  :   0 brhc  :   0 brhs  :   0 brid  :   0 
brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 brne  :  18 brpl  :   0 
brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 brvs  :   0 bset  :   0 
bst   :   0 cbi   :   7 cbr   :   0 clc   :   1 clh   :   0 cli   :   0 
cln   :   0 clr   :  12 cls   :   0 clt   :   0 clv   :   0 clz   :   0 
com   :   2 cp    :   3 cpc   :   1 cpi   :   4 cpse  :   0 dec   :  16 
eor   :   0 icall :   0 ijmp  :   0 in    :   1 inc   :   4 ld    :   2 
ldd   :   0 ldi   :  66 lds   :  14 lsl   :   2 lsr   :   6 mov   :  14 
neg   :   0 nop   :  20 or    :   0 ori   :   0 out   :   2 pop   :   1 
push  :   2 rcall :  79 ret   :  33 reti  :   0 rjmp  :   6 rol   :   2 
ror   :   6 sbc   :   0 sbci  :   1 sbi   :   6 sbic  :   1 sbis  :   0 
sbr   :   0 sbrc  :   2 sbrs  :   1 sec   :   1 seh   :   0 sei   :   0 
sen   :   0 ser   :   0 ses   :   0 set   :   0 sev   :   0 sez   :   0 
sleep :   0 st    :   1 std   :   0 sts   :  16 sub   :   1 subi  :   4 
swap  :   0 tst   :   0 wdr   :   0 
Instructions used: 42 out of 99 (42.4%)

"ATtiny10" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x000394    716    200    916    1024  89.5%
[.dseg] 0x000040 0x000060      0     14     14      32  43.8%
[.eseg] 0x000000 0x000000      0      0      0       0      -

Assembly complete, 0 errors, 34 warnings
